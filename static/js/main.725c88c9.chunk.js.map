{"version":3,"sources":["PathfindingVisualizer/Node.jsx","pathfinding algoritms/dijkstra.js","pathfinding algoritms/astar.js","pathfinding algoritms/bfs.js","pathfinding algoritms/dfs.js","pathfinding algoritms/greedy.js","maze algoritms/randomMaze.js","maze algoritms/recursiveMaze.js","maze algoritms/recursiveBacktracker.js","maze algoritms/spriralMaze.js","maze algoritms/prim.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","row","type","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unVisitedNodes","nodes","node","push","getAllNodes","length","sort","nodeOne","nodeTwo","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getShortestDijkstraPath","nodesInShortestPathOrder","currentNode","unshift","undefined","astar","gScore","hScore","getManhattanDistance","openSet","fScore","console","log","closed","getNeighbors","tentativeGscoreToNeighbor","isInSet","set","i","currentNodeRow","currentNodeCol","finishNodeRow","finishNodeCol","Math","abs","getShortestAstarPath","bfs","structure","visitedNodes","name","getShortestBFSPath","dfs","unvisitedNodes","isWall","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","neighbours","neighbour","getShortestDFSPath","greedy","getShortestGreedyPath","randomMaze","random","weightValue","recursiveDivisionMaze","nodesToAnimate","isPassage","map","cell","addToArray","index","reverse","lastRow","lastCol","orientation","chooseOrientation","devide","firstRow","firstCol","width","height","firstValidRow","lastValidRow","firstValidCol","lastValidCol","validWidth","validHeight","passageIdx","rowIdxToBeWall","floor","forEach","colIdxToBeWall","idx","array","recursiveBacktracker","visited","nodesToRemoveWall","currentRow","currentCol","stack","next","getRBNeighbors","nextRow","nextCol","wall","getCellBeetween","pop","row1","col1","row2","col2","possibleNeighbors","spiral","prim","mazeSpeed","frontiersList","frontiers","getFrontiers","selectedIdx","getNeighborsPrime","neighborRow","neighborCol","splice","algorithmSpeed","wIsPressed","PathfinidingVisualizer","state","mouseIsPressed","nodeToChange","document","addEventListener","event","key","initializeGrid","setState","newGrid","getNewGridWithNewNodeType","algorithm","findPath","clearNodes","algorithmCallback","getShortestPathCallback","getNodeByType","nodeInShortestPath","animateAlgorithm","setTimeout","animateShortestPath","nodeComponent","getElementById","classList","add","findMaze","mazeCallback","clearWallsAndWeights","animateMaze","visualizingAlgorithm","generatingMaze","slice","onClick","visualizeAlgorithm","visualizeMaze","changeAlgoritmSpeed","clearBoard","clearPath","class","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseLeave","getNode","newType","newNode","givenType","speed","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.725c88c9.chunk.js","sourcesContent":["import './Node.css';\r\nimport React,{Component} from 'react'\r\n\r\nexport default class Node extends Component{\r\n  \r\n    render(){\r\n        const {\r\n            col,\r\n            row,\r\n            type,\r\n            // isVisited,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            onMouseLeave\r\n          } = this.props;\r\n\r\n        const extraClassName=type==='start'?'start-node':\r\n                             type==='finish'?'finish-node':\r\n                             type==='wall'?'wall-node':\r\n                             type==='weight'?'weight-node':\r\n                             \"\"\r\n\r\n        \r\n                           \r\n        return ( <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`} \r\n        onMouseDown={()=>onMouseDown(row,col,type)}\r\n        onMouseEnter={()=>onMouseEnter(row,col,type)}\r\n        onMouseUp={()=>onMouseUp()}\r\n        onMouseLeave={()=>onMouseLeave()}\r\n        ></td>)\r\n        \r\n    }\r\n}","export function dijkstra(grid,startNode,finishNode){ \r\n\r\n   const visitedNodesInOrder=[]\r\n   startNode.distance=0\r\n   const unVisitedNodes=getAllNodes(grid)\r\n   \r\n   \r\n\r\n   while(!!unVisitedNodes.length){\r\n       sortNodesByDistance(unVisitedNodes)\r\n       const closestNode = unVisitedNodes.shift();\r\n       if(closestNode.type==='wall')continue\r\n       if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n       closestNode.isVisited=true\r\n       visitedNodesInOrder.push(closestNode);\r\n\r\n       updateUnvisitedNeighbors(closestNode, grid);\r\n       if(closestNode===finishNode)return visitedNodesInOrder\r\n   }\r\n}\r\nfunction getAllNodes(grid){\r\n    let nodes=[]\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            nodes.push(node)\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      if(neighbor.type==='weight'){\r\n        neighbor.distance=node.distance+5\r\n      }else{\r\n        neighbor.distance=node.distance+1\r\n      }\r\n     \r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n \r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\nfunction sortNodesByDistance(nodes){\r\n    nodes.sort((nodeOne, nodeTwo) => nodeOne.distance - nodeTwo.distance);\r\n}\r\nexport function getShortestDijkstraPath(finishNode) {\r\n  \r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      if(currentNode!==undefined){\r\n        currentNode = currentNode.previousNode;\r\n      }else{\r\n        // console.log(nodesInShortestPathOrder)\r\n        return nodesInShortestPathOrder;\r\n      }\r\n    }\r\n}\r\n","export function astar(grid,startNode,finishNode){\r\n\r\n  const visitedNodesInOrder=[]\r\n  //gScore is the distance from a node to the startnode\r\n  startNode.gScore=0\r\n  //hScore is the distance from a node to the finish node\r\n  startNode.hScore=getManhattanDistance(startNode,finishNode)\r\n\r\n  const openSet=[]\r\n  openSet.push(startNode)\r\n  \r\n\r\n  while(openSet.length > 0){\r\n    \r\n    sortNodesByFscore(openSet)\r\n    \r\n    var currentNode=openSet.shift()\r\n    // console.log(openSet)\r\n    console.log(currentNode)\r\n    visitedNodesInOrder.push(currentNode)\r\n\r\n    if(currentNode===finishNode)return visitedNodesInOrder\r\n    \r\n      // openSet.splice(lowestFScore,1)\r\n    \r\n    \r\n    currentNode.closed=true\r\n    for(let neighbor of getNeighbors(currentNode,grid)){\r\n      // console.log(neighbor.closed)\r\n\r\n      if(neighbor.type==='wall')continue\r\n      if(neighbor.closed)continue\r\n\r\n      let tentativeGscoreToNeighbor\r\n      if(neighbor.type==='weight'){\r\n        tentativeGscoreToNeighbor=currentNode.gScore+10\r\n      }else{\r\n        tentativeGscoreToNeighbor=currentNode.gScore+1\r\n      }\r\n\r\n      if(tentativeGscoreToNeighbor<neighbor.gScore){\r\n        // console.log(neighbor)\r\n        neighbor.gScore=tentativeGscoreToNeighbor\r\n        neighbor.hScore=getManhattanDistance(neighbor,finishNode)\r\n        neighbor.fScore = neighbor.gScore + neighbor.hScore;\r\n        neighbor.previousNode = currentNode;\r\n        // console.log(openSet)\r\n        if (!isInSet(neighbor, openSet)) {\r\n          openSet.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    \r\n  }\r\n  \r\n  return visitedNodesInOrder\r\n}\r\nfunction sortNodesByFscore(nodes){\r\n  nodes.sort((nodeOne, nodeTwo) => nodeOne.fScore - nodeTwo.fScore);\r\n}\r\n\r\nfunction isInSet(node, set) {\r\n  for (let i = set.length - 1; i >= 0; i++) {\r\n    if (set[i].row === node.row && set[i].col === node.col) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getManhattanDistance(currentNode, finishNode) {\r\n    const currentNodeRow=currentNode.row\r\n    const currentNodeCol=currentNode.col\r\n    const finishNodeRow=finishNode.row\r\n    const finishNodeCol=finishNode.col\r\n    \r\n    const manhattanDistance= Math.abs(currentNodeCol-finishNodeCol)+Math.abs(currentNodeRow-finishNodeRow)\r\n    \r\n    return manhattanDistance\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors\r\n}\r\nexport function getShortestAstarPath(finishNode) {\r\n  \r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    if(currentNode!==undefined){\r\n      currentNode = currentNode.previousNode;\r\n    }else{\r\n      console.log(nodesInShortestPathOrder)\r\n      return nodesInShortestPathOrder;\r\n    }\r\n  }\r\n}","export function bfs(grid,startNode,finishNode){\r\n    const structure = [];\r\n    const visitedNodes = [];\r\n    startNode.isVisited = true;\r\n    structure.push(startNode);\r\n  \r\n    while (structure.length>0) {\r\n    \r\n      let currentNode = structure.shift()\r\n    //   console.log(queue)\r\n       visitedNodes.push(currentNode);\r\n      if (currentNode === finishNode) {\r\n        // console.log(visitedNodes)\r\n        return visitedNodes;\r\n      }\r\n      // console.log(getNeighbors(currentNode,grid))\r\n      for (let neighbor of getNeighbors(currentNode,grid) ){\r\n        if (neighbor.type==='wall') {\r\n          continue;\r\n        }\r\n       \r\n        if(neighbor.isVisited===false){\r\n          neighbor.isVisited = true;\r\n          neighbor.previousNode = currentNode;\r\n          structure.push(neighbor);\r\n        }\r\n        \r\n      }\r\n    }\r\n    return visitedNodes\r\n}\r\n\r\nfunction getNeighbors(node,grid,name){\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n \r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  \r\n\r\n    \r\n  return neighbors;\r\n}\r\nexport function getShortestBFSPath(finishNode){\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    if(currentNode!==undefined){\r\n      currentNode = currentNode.previousNode;\r\n    }else{\r\n      // console.log(nodesInShortestPathOrder)\r\n      return nodesInShortestPathOrder;\r\n    }\r\n  }\r\n}\r\n","export function dfs(grid,startNode,finishNode){\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n      }\r\n    // console.log(\"hey\");\r\n    const visitedNodesInOrder = [];\r\n    const unvisitedNodes = [];\r\n      unvisitedNodes.push(startNode);\r\n      while (unvisitedNodes.length !== 0) {\r\n        let closestNode = unvisitedNodes.shift();\r\n        if (closestNode.isWall) continue;\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n        visitedNodesInOrder.push(closestNode);\r\n        closestNode.isVisited = true;\r\n        let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\r\n        for (let unvisitedNeighbour of unvisitedNeighbours) {\r\n          unvisitedNeighbour.previousNode = closestNode;\r\n          unvisitedNodes.unshift(unvisitedNeighbour);\r\n        }\r\n      }\r\n      return visitedNodesInOrder;\r\n}\r\n\r\n\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n    // console.log(\"No\");\r\n    const neighbours = [];\r\n    const { row, col } = node;\r\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n\r\n    return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n  }\r\n\r\nexport function getShortestDFSPath(finishNode){\r\n    // console.log(\"hello\");\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      if(currentNode!==undefined){\r\n      currentNode = currentNode.previousNode;\r\n    } else{\r\n      return nodesInShortestPathOrder;\r\n    }\r\n  }\r\n    \r\n}\r\n","export function greedy(grid,startNode,finishNode){ \r\n\r\n    const visitedNodesInOrder=[]\r\n    startNode.distance=getManhattanDistance(startNode,finishNode)\r\n    const unVisitedNodes=getAllNodes(grid)\r\n    \r\n    \r\n \r\n    while(!!unVisitedNodes.length){\r\n        sortNodesByDistance(unVisitedNodes)\r\n        const closestNode = unVisitedNodes.shift();\r\n        if(closestNode.type==='wall')continue\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited=true\r\n        visitedNodesInOrder.push(closestNode);\r\n \r\n        updateUnvisitedNeighbors(closestNode, grid,finishNode);\r\n        if(closestNode===finishNode)return visitedNodesInOrder\r\n    }\r\n }\r\n function getAllNodes(grid){\r\n     let nodes=[]\r\n     for(const row of grid){\r\n         for(const node of row){\r\n             nodes.push(node)\r\n         }\r\n     }\r\n     return nodes;\r\n }\r\n function updateUnvisitedNeighbors(node, grid,finishNode) {\r\n     const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n     for (const neighbor of unvisitedNeighbors) {\r\n       if(neighbor.type==='weight'){\r\n         neighbor.distance=getManhattanDistance(neighbor,finishNode)+5\r\n       }else{\r\n         neighbor.distance=getManhattanDistance(neighbor,finishNode)\r\n       }\r\n      \r\n       neighbor.previousNode = node;\r\n     }\r\n   }\r\n  \r\n function getUnvisitedNeighbors(node, grid) {\r\n   const neighbors = [];\r\n   const {col, row} = node;\r\n   if (row > 0) neighbors.push(grid[row - 1][col]);\r\n   if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n   if (col > 0) neighbors.push(grid[row][col - 1]);\r\n   if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n   return neighbors.filter(neighbor => !neighbor.isVisited);\r\n }\r\n function sortNodesByDistance(nodes){\r\n     nodes.sort((nodeOne, nodeTwo) => nodeOne.distance - nodeTwo.distance);\r\n }\r\n function getManhattanDistance(currentNode, finishNode) {\r\n    const currentNodeRow=currentNode.row\r\n    const currentNodeCol=currentNode.col\r\n    const finishNodeRow=finishNode.row\r\n    const finishNodeCol=finishNode.col\r\n    \r\n    const manhattanDistance= Math.abs(currentNodeCol-finishNodeCol)+Math.abs(currentNodeRow-finishNodeRow)\r\n    \r\n    return manhattanDistance\r\n}\r\n export function getShortestGreedyPath(finishNode) {\r\n   \r\n     const nodesInShortestPathOrder = [];\r\n     let currentNode = finishNode;\r\n     while (currentNode !== null) {\r\n       nodesInShortestPathOrder.unshift(currentNode);\r\n       if(currentNode!==undefined){\r\n         currentNode = currentNode.previousNode;\r\n       }else{\r\n         // console.log(nodesInShortestPathOrder)\r\n         return nodesInShortestPathOrder;\r\n       }\r\n     }\r\n }\r\n ","export default function randomMaze(grid,type){\r\n    for(let row of grid){\r\n        for(let node of row){\r\n           \r\n            if(node.type ==='finish'||node.type ==='start')continue\r\n            let random = Math.random();\r\n\t\t\tlet randomTwo =type==='wall'? 0.35: 0.25;\r\n\t\t\tif (random < randomTwo ) {\r\n                // console.log(node)\r\n                // console.log(node.type)\r\n               node.type=type\r\n               if(type==='weight'){\r\n                node.weightValue=15\r\n            }\r\n            }\r\n            \r\n        }\r\n    }\r\n  return grid\r\n}","export default function recursiveDivisionMaze (grid){\r\n    console.log('rd start');\r\n    const nodesToAnimate = []\r\n\r\n    const isPassage = grid.map(row=>row.map(cell=>false))\r\n\r\n    //make edges wall. just for more beautiful look\r\n    grid[0].map(cell=>addToArray(nodesToAnimate,cell));\r\n\r\n    grid.map(row=>row.map((node,index)=> {\r\n        if(index===grid[0].length-1){\r\n            if(node.type!=='start'||node.type!=='finish'){\r\n              addToArray(nodesToAnimate,node)\r\n            }\r\n        }\r\n    }));\r\n\r\n    grid[grid.length-1].reverse().map(cell=>addToArray(nodesToAnimate,cell));\r\n\r\n    grid.map(row=>row.map((cell, index)=> index===0  && addToArray(nodesToAnimate,cell)));\r\n\r\n\r\n    let firstRow = 1;\r\n    let lastRow = grid.length - 2;\r\n    let firstCol = 1;\r\n    let lastCol = grid[0].length - 2;\r\n\r\n   let orientation = chooseOrientation(grid,firstRow,lastRow,firstCol,lastCol);\r\n    devide(grid,firstRow,lastRow,firstCol,lastCol,orientation,nodesToAnimate,isPassage);\r\n\r\n    \r\n    \r\n\r\n    return nodesToAnimate\r\n}\r\n\r\n\r\n//-------------------------\r\n//   Recursive Devision Helper Functions\r\n//---------------------------\r\n\r\n\r\n//#1-choose orientation\r\nconst chooseOrientation = (grid,firstRow,lastRow,firstCol,lastCol) =>{\r\n    let width = lastCol - firstCol;\r\n    let height = lastRow - firstRow;\r\n    if(width>height){\r\n        return 'Vertical'\r\n    }else if(height>width){\r\n        return 'Horizontal'\r\n    }else{\r\n        const num = Math.random();\r\n        return (num<0.5) ? 'Vertical' : 'Horizontal'\r\n    }\r\n}\r\n\r\n\r\n//#2- devide\r\nconst devide = (grid,firstRow,lastRow,firstCol,lastCol,orientation,nodesToAnimate,isPassage) =>{\r\n    let width = lastCol - firstCol + 1;\r\n    let height = lastRow - firstRow + 1;\r\n\r\n    let firstValidRow = firstRow ;\r\n    let lastValidRow = lastRow;\r\n    let firstValidCol = firstCol;\r\n    let lastValidCol = lastCol;\r\n\r\n\r\n    if(orientation==='Horizontal'){\r\n        firstValidRow += 1\r\n        lastValidRow -= 1\r\n    }else{\r\n        firstValidCol += 1\r\n        lastValidCol -= 1\r\n    }\r\n    \r\n\r\n    let validWidth = lastValidCol - firstValidCol + 1;\r\n    let validHeight = lastValidRow - firstValidRow + 1;\r\n    \r\n\r\n    if(width<2 || height<2 || validHeight<1 || validWidth<1) return;\r\n\r\n    if(orientation==='Horizontal'){\r\n\r\n\r\n        let rowIdxToBeWall = Math.floor(Math.random()* validHeight) + firstValidRow;\r\n        //let passageIdx = Math.floor(Math.random() * validWidth) + firstValidCol;\r\n\r\n        let passageIdx;\r\n        if (isPassage[rowIdxToBeWall][firstCol-1]){\r\n\t\t\t passageIdx = firstCol;\r\n\t\t} else if (isPassage[rowIdxToBeWall][lastCol+1]){\r\n\t\t\t passageIdx = lastCol;\r\n\t\t} else {\r\n\t\t\t passageIdx = Math.random()>0.5 ? firstCol: lastCol; // random end assignment\r\n        }\r\n\r\n        grid[rowIdxToBeWall].forEach((node, index)=>{\r\n            if(node.type==='start'||node.type==='finish'){\r\n                isPassage[rowIdxToBeWall][index] = true;\r\n            }\r\n            if(isPassage[rowIdxToBeWall][index]) return\r\n            if(index< firstValidCol  || index>lastValidCol) return;\r\n            if(index===passageIdx){\r\n                isPassage[rowIdxToBeWall][index] = true;\r\n                return\r\n            }\r\n            \r\n             addToArray(nodesToAnimate,node)\r\n            \r\n        })\r\n\r\n        // upper side\r\n        let orientation = chooseOrientation(grid,firstRow,rowIdxToBeWall-1,firstCol,lastCol);\r\n        devide(grid,firstRow,rowIdxToBeWall-1,firstCol,lastCol,orientation,nodesToAnimate,isPassage);\r\n\r\n        //Bottom side\r\n        orientation = chooseOrientation(grid,rowIdxToBeWall+1,lastRow,firstCol,lastCol);\r\n        devide(grid,rowIdxToBeWall+1,lastRow,firstCol,lastCol,orientation,nodesToAnimate,isPassage);\r\n\r\n\r\n    }else{\r\n\r\n        let colIdxToBeWall = Math.floor(Math.random()* validWidth ) + firstValidCol;\r\n        //let passageIdx = Math.floor(Math.random() * validHeight) + firstValidRow;\r\n\r\n\r\n        let passageIdx;\r\n        if (firstRow-1>=0 && isPassage[firstRow-1][colIdxToBeWall]){\r\n\t\t\tpassageIdx = firstRow;\r\n\t\t} else if (lastRow+1<grid.length && isPassage[lastRow+1][colIdxToBeWall]){\r\n\t\t\tpassageIdx = lastRow;\r\n\t\t} else {\r\n\t\t\tpassageIdx = Math.random()>0.5 ? firstRow: lastRow; // random end assignment\r\n\t\t}\r\n\r\n        grid.forEach((row, index)=>{\r\n            \r\n            if (index<firstValidRow || index>lastValidRow) return;\r\n            if (index === passageIdx){\r\n                isPassage[index][colIdxToBeWall] = true;\r\n                return;\r\n            }\r\n\r\n            row.forEach((node, idx)=>{\r\n\r\n                if(node.type==='start'||node.type==='finish'){\r\n                    isPassage[index][idx] = true;\r\n                }\r\n                if(isPassage[index][idx]) return;\r\n                \r\n                idx===colIdxToBeWall && nodesToAnimate.push(node);\r\n        })});\r\n\r\n\r\n        //left side\r\n        orientation = chooseOrientation(grid,firstRow,lastRow,firstCol,colIdxToBeWall-1);\r\n        devide(grid,firstRow,lastRow,firstCol,colIdxToBeWall - 1 ,orientation,nodesToAnimate,isPassage);\r\n\r\n\r\n        //right side\r\n        orientation = chooseOrientation(grid,firstRow,lastRow,colIdxToBeWall + 1,lastCol);\r\n        devide(grid,firstRow,lastRow,colIdxToBeWall + 1, lastCol ,orientation,nodesToAnimate,isPassage);\r\n\r\n    }\r\n\r\n}\r\nfunction addToArray(array,node){\r\n    if(node.type!=='start'&&node.type!=='finish'){\r\n        array.push(node)        \r\n    }\r\n}\r\n\r\n","\r\nexport default function recursiveBacktracker (grid){\r\n    \r\n    \r\n    \r\n    grid.map(row=>row.map((node)=> {\r\n        \r\n            if(node.type==='start'||node.type==='finish')return\r\n              node.type='wall'\r\n            \r\n        \r\n    }));\r\n\r\n    const visited = grid.map(row=>row.map(cell=>false));\r\n\r\n    const nodesToRemoveWall = []\r\n\r\n    let [currentRow,currentCol] = [0,0];\r\n    \r\n    visited[currentRow][currentCol] = true;\r\n\r\n    let stack = []\r\n\r\n    \r\n    while(true){\r\n        //counter += 1;\r\n\r\n        nodesToRemoveWall.push(grid[currentRow][currentCol]);\r\n\r\n    \r\n    let next = getRBNeighbors(currentRow,currentCol, grid,visited);\r\n\r\n    if(next){\r\n        stack.push(next);\r\n\r\n        let [nextRow,nextCol] = next;\r\n\r\n        visited[nextRow][nextCol] = true;\r\n\r\n        let wall = getCellBeetween(currentRow, currentCol,nextRow,nextCol,grid);\r\n\r\n        nodesToRemoveWall.push(wall);\r\n\r\n        currentRow = nextRow;\r\n        currentCol = nextCol;\r\n\r\n    }else{\r\n\r\n        if(stack.length>0){\r\n\r\n            next = stack.pop();\r\n\r\n            let [nextRow, nextCol] = next;\r\n\r\n            currentRow=nextRow;\r\n            currentCol = nextCol;\r\n        }else{\r\n            break;\r\n        }\r\n       \r\n    }\r\n    }\r\n\r\n    \r\n    \r\n\r\n    return nodesToRemoveWall;\r\n\r\n}\r\nconst getCellBeetween = (row1,col1,row2,col2,grid)=>{\r\n    if(row1===row2){\r\n        if(col1>col2){\r\n            return grid[row1][col2+1]\r\n        }else{\r\n            return grid[row1][col1+1]\r\n        }\r\n        \r\n    }else if(col1===col2){\r\n        if(row2>row1){\r\n            return grid[row1+1][col1]\r\n        }else{\r\n            return grid[row2+1][col1]\r\n        }\r\n    }\r\n}\r\n\r\nconst getRBNeighbors = (currentRow,currentCol,grid,visited)=>{\r\n\r\n    let possibleNeighbors = [\r\n        [currentRow+2,currentCol],\r\n        [currentRow-2, currentCol],\r\n        [currentRow, currentCol+2],\r\n        [currentRow, currentCol-2]\r\n    ]\r\n\r\n\r\n    let neighbors = [];\r\n\r\n    for(let i=0;i<possibleNeighbors.length;i++){\r\n        let [row,col] = possibleNeighbors[i];\r\n        if(row<0 || row>grid.length-1 || col<0 || col>grid[0].length-1) continue;\r\n        if(visited[row][col]) continue;\r\n        neighbors.push([row,col])\r\n    }\r\n\r\n    if(neighbors.length>0){\r\n        const nextIdx = Math.floor(Math.random()*neighbors.length);\r\n        return neighbors[nextIdx];\r\n    }else{\r\n        return;\r\n    }\r\n\r\n}\r\n\r\n","export default function spiral (grid){\r\n    console.log('spiral start')\r\n    const nodesToAnimate = [];\r\n\r\n    let firstRow =0\r\n    let lastRow = grid.length-1;\r\n    let firstCol = 0;\r\n    let lastCol = grid[0].length-1;\r\n\r\n    while (lastRow-firstRow>2&& lastCol-firstRow>2){\r\n        for(let col=firstCol;col<lastCol;col++){\r\n            nodesToAnimate.push(grid[firstRow][col])\r\n            //console.log(grid[firstRow][col])\r\n        }\r\n        for(let row=firstRow;row<lastRow;row++){\r\n            nodesToAnimate.push(grid[row][lastCol])\r\n        }\r\n        for(let col=lastCol;col>firstCol;col--){\r\n            nodesToAnimate.push(grid[lastRow][col])\r\n        }\r\n        for(let row=lastRow;row>firstRow+2;row--){\r\n            nodesToAnimate.push(grid[row][firstCol+1])\r\n        }\r\n\r\n        nodesToAnimate.push(grid[firstRow+3][firstCol+2])\r\n        nodesToAnimate.push(grid[firstRow+3][firstCol+3])\r\n        firstRow += 3\r\n        lastRow -= 3\r\n        firstCol += 4\r\n        lastCol -=3\r\n    }\r\n   return nodesToAnimate\r\n}\r\n","export default function prim  (grid,mazeSpeed){\r\n    \r\n    let start;\r\n    let end;\r\n    grid.map((row,index)=>row.map((cell,idx)=>{\r\n        if(cell.type==='start'){\r\n            start = [index,idx];\r\n            return;\r\n        }else if(cell.type==='finish'){\r\n            end = [index,idx];\r\n            return;\r\n        }else{\r\n            cell.type='wall';\r\n        }\r\n        \r\n    }));\r\n\r\n    const isWall = grid.map(row=>row.map(cell=>true));\r\n    const visited = grid.map(row=>row.map(cell=>false));\r\n\r\n    let currentRow = Math.floor(Math.random()*grid.length);\r\n    let currentCol = Math.floor(Math.random()*grid[0].length);\r\n\r\n    const frontiersList = [];\r\n\r\n    const nodesToRemoveWall = [];\r\n\r\n    nodesToRemoveWall.push(grid[currentRow][currentCol]);\r\n\r\n    isWall[currentRow][currentCol] = false;\r\n\r\n    let frontiers = getFrontiers(grid,currentRow,currentCol,isWall,visited);\r\n    \r\n\r\n    for(let i=0; i<frontiers.length; i++){\r\n        frontiersList.push(frontiers[i])\r\n        let [row,col] = frontiers[i]\r\n        visited[row][col] = true;\r\n    }\r\n   \r\n    while (frontiersList.length>0){\r\n       \r\n        let selectedIdx = Math.floor(Math.random()*frontiersList.length);\r\n\r\n        let [currentRow,currentCol] = frontiersList[selectedIdx];\r\n\r\n        let neighbors = getNeighborsPrime(grid,currentRow,currentCol,isWall);\r\n\r\n        let randomNeighborIdx = Math.floor(Math.random()*neighbors.length);\r\n\r\n        let neighbor = neighbors[randomNeighborIdx];\r\n\r\n        let [neighborRow,neighborCol] = neighbor;\r\n\r\n        let wall = getCellBeetween(neighborRow,neighborCol,currentRow,currentCol,grid);\r\n\r\n        nodesToRemoveWall.push(wall);\r\n\r\n        nodesToRemoveWall.push(grid[currentRow][currentCol]);\r\n\r\n        isWall[neighborRow][neighborCol] = false;\r\n        isWall[currentRow][currentCol] =false;\r\n\r\n        frontiers = getFrontiers(grid,currentRow,currentCol,isWall,visited);\r\n\r\n        for(let i=0; i<frontiers.length;i++){\r\n            frontiersList.push(frontiers[i]);\r\n            let [row,col] = frontiers[i]\r\n            visited[row][col] = true;\r\n        }\r\n\r\n        frontiersList.splice(selectedIdx,1)\r\n\r\n        }\r\n        return nodesToRemoveWall\r\n\r\n    }\r\n    const getFrontiers = (grid,currentRow,currentCol,isWall,visited)=>{\r\n        let possibleNeighbors = [\r\n            [currentRow,currentCol-2],\r\n            [currentRow, currentCol+2],\r\n            [currentRow-2, currentCol],\r\n            [currentRow+2,currentCol]\r\n        ]\r\n    \r\n        let frontiers=[]\r\n        for(let i=0; i<possibleNeighbors.length; i++){\r\n            let [row,col] = possibleNeighbors[i];\r\n            if(row>=0 && row<grid.length && col>=0 && col<grid[0].length){\r\n                if (isWall[row][col] && !visited[row][col]){\r\n                    frontiers.push([row,col])\r\n                }\r\n               \r\n            }\r\n        }\r\n    \r\n        return frontiers;\r\n    }\r\n    \r\n    const getNeighborsPrime = (grid,currentRow,currentCol,isWall)=>{\r\n        let possibleNeighbors = [\r\n            [currentRow,currentCol-2],\r\n            [currentRow, currentCol+2],\r\n            [currentRow-2, currentCol],\r\n            [currentRow+2,currentCol]\r\n        ]\r\n    \r\n        let neighbors=[]\r\n        for(let i=0; i<possibleNeighbors.length; i++){\r\n            let [row,col] = possibleNeighbors[i];\r\n            if(row>=0 && row<grid.length && col>=0 && col<grid[0].length){\r\n                if (isWall[row][col]){\r\n                    continue\r\n                }else{\r\n                    neighbors.push([row,col])\r\n                }\r\n               \r\n            }\r\n        }\r\n    \r\n        return neighbors;\r\n    }\r\n    \r\n    \r\n    \r\nconst getCellBeetween = (row1,col1,row2,col2,grid)=>{\r\n    if(row1===row2){\r\n        if(col1>col2){\r\n            return grid[row1][col2+1]\r\n        }else{\r\n            return grid[row1][col1+1]\r\n        }\r\n        \r\n    }else if(col1===col2){\r\n        if(row2>row1){\r\n            return grid[row1+1][col1]\r\n        }else{\r\n            return grid[row2+1][col1]\r\n        }\r\n    }\r\n}\r\n","import React, {Component} from 'react';\r\nimport './PathfindingVisualizer.css';\r\nimport Node from './Node'\r\n\r\nimport { dijkstra,getShortestDijkstraPath } from '../pathfinding algoritms/dijkstra';\r\nimport {astar ,getShortestAstarPath} from '../pathfinding algoritms/astar';\r\nimport {bfs,getShortestBFSPath} from '../pathfinding algoritms/bfs';\r\nimport {dfs,getShortestDFSPath} from '../pathfinding algoritms/dfs';\r\nimport {greedy,getShortestGreedyPath} from '../pathfinding algoritms/greedy';\r\n// import {bidirectionalGreedySearch,getNodesInShortestPathOrderBidirectionalGreedySearch} from '../pathfinding algoritms/bidirectionalGreedySearch';\r\n  \r\nimport randomMaze from '../maze algoritms/randomMaze'\r\nimport  recursiveDivisionMaze  from '../maze algoritms/recursiveMaze';\r\nimport  recursiveBacktracker  from '../maze algoritms/recursiveBacktracker';\r\nimport spiral from '../maze algoritms/spriralMaze';\r\nimport prim from '../maze algoritms/prim';\r\n\r\nlet startNodeRow = 10;\r\nlet startNodeCol = 10;\r\nlet finishNodeRow = 10;\r\nlet finishNodeCol = 40;\r\n\r\nlet algorithmRunning=false\r\nlet algorithmSpeed=10;\r\n\r\nlet wIsPressed=false\r\n\r\nexport default class PathfinidingVisualizer extends Component{\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            grid:[],\r\n            mouseIsPressed:false,\r\n            nodeToChange:''\r\n            \r\n        }\r\n        document.addEventListener('keydown', function(event){\r\n            if(event.key===\"w\"){\r\n                wIsPressed=true\r\n            }\r\n          })\r\n          document.addEventListener('keyup', function(event){\r\n            if(event.key===\"w\"){\r\n               wIsPressed=false\r\n            }\r\n          })\r\n      \r\n    }\r\n    componentDidMount(){\r\n          const grid=initializeGrid()\r\n          this.setState({grid});\r\n         \r\n    }\r\n   \r\n    \r\n    handleMouseDown(row,col,type){\r\n        let newGrid\r\n        if(algorithmRunning)return\r\n        \r\n        switch (type) {\r\n            case 'normal-node':\r\n                if(wIsPressed){\r\n                    newGrid=getNewGridWithNewNodeType(this.state.grid,row,col,'weight')\r\n                    this.setState({grid: newGrid,mouseIsPressed:true,nodeToChange:'weight'})\r\n                    break \r\n                }else{\r\n                    newGrid=getNewGridWithNewNodeType(this.state.grid,row,col,'wall')\r\n                    this.setState({grid: newGrid,mouseIsPressed:true,nodeToChange:'wall'})\r\n                }\r\n                break;\r\n            case 'wall':\r\n                newGrid=getNewGridWithNewNodeType(this.state.grid,row,col,'normal-node')\r\n                this.setState({grid: newGrid,mouseIsPressed:true,nodeToChange:'normal-node'})\r\n                break;\r\n            case 'start':\r\n                this.setState({mouseIsPressed:true, nodeToChange:'start'})\r\n                \r\n                break;\r\n            case 'finish':\r\n                this.setState({mouseIsPressed:true, nodeToChange:'finish'})\r\n                break;\r\n            default:\r\n               \r\n                break;\r\n        }\r\n   \r\n    }\r\n    handleMouseEnter(row,col,type){\r\n        if(algorithmRunning)return\r\n        if(!this.state.mouseIsPressed)return\r\n        if(type==='wall'||type==='normal-node'){\r\n            let newGrid =getNewGridWithNewNodeType(this.state.grid,row,col,this.state.nodeToChange)\r\n            this.setState({grid: newGrid});\r\n        }  \r\n    } \r\n    handleMouseUp(){\r\n        this.setState({mouseIsPressed: false});\r\n    }\r\n    handleMouseLeave(row,col,type){\r\n        let newGrid\r\n        if(!this.state.mouseIsPressed)return\r\n        if((type==='start'||type==='finish')&&this.state.nodeToChange!=='wall'){\r\n            newGrid=getNewGridWithNewNodeType(this.state.grid,row,col,'normal-node')\r\n            this.setState({grid: newGrid});\r\n        }\r\n           \r\n    }\r\n\r\n    visualizeAlgorithm(algorithm) {\r\n    //    this.clearPath(this.state.grid) comment Me\r\n        switch (algorithm) {\r\n            case 0:\r\n                break;\r\n            case 1:\r\n            //this.visualizeDijkstra(startNode, finishNode); comment Me\r\n                this.findPath(dijkstra,getShortestDijkstraPath);\r\n            break;\r\n            case 2:\r\n                this.findPath(astar,getShortestAstarPath,);\r\n            break;\r\n            case 3:\r\n                this.clearNodes(this.state.grid,'weight')\r\n                this.findPath(bfs,getShortestBFSPath)\r\n                break;\r\n            case 4:\r\n                this.clearNodes(this.state.grid,'weight')\r\n                this.findPath(dfs,getShortestDFSPath)\r\n                break;\r\n            case 5:\r\n                this.findPath(greedy,getShortestGreedyPath);\r\n            break;\r\n            case 6:\r\n                // this.findPath(bidirectionalGreedySearch,getNodesInShortestPathOrderBidirectionalGreedySearch);\r\n            break;\r\n          default:\r\n              break\r\n        }\r\n        // algorithmRunning=false comment Me\r\n      }\r\n     \r\n  \r\n    findPath(algorithmCallback,getShortestPathCallback) {\r\n        // this.setState({algorithmRunning:true}) comment Me\r\n       \r\n        let startNode = getNodeByType(this.state.grid,'start')\r\n        let finishNode =getNodeByType(this.state.grid,'finish')\r\n\r\n       \r\n        \r\n        \r\n        const visitedNodesInOrder = algorithmCallback(\r\n            this.state.grid,\r\n            startNode,\r\n            finishNode,\r\n        \r\n        )\r\n       \r\n        const nodeInShortestPath=getShortestPathCallback(finishNode)\r\n        \r\n        this.animateAlgorithm(visitedNodesInOrder,nodeInShortestPath);\r\n       // algorithmRunning=false comment Me\r\n    }\r\n     \r\n    animateAlgorithm(visitedNodesInOrder,nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, algorithmSpeed * i);\r\n                return;\r\n                }\r\n        const node = visitedNodesInOrder[i];\r\n        const nodeComponent=document.getElementById(`node-${node.row}-${node.col}`)\r\n          \r\n          setTimeout(() => {\r\n            nodeComponent.classList.add('visited')\r\n          }, algorithmSpeed * i);\r\n         \r\n        }\r\n      }\r\n      animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\r\n          setTimeout(() => {\r\n            const node = nodesInShortestPathOrder[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).classList.add('node-shortest-path')\r\n          }, 50 * i);\r\n        }\r\n      \r\n      }\r\n      visualizeMaze(algorithm) {\r\n        // this.clearWallsAndWeights(this.state.grid) comment Me\r\n        let newGrid\r\n        switch (algorithm) {\r\n            case 0:\r\n                break;\r\n            case 1:\r\n              this.findMaze(recursiveDivisionMaze,'wall')\r\n            break;\r\n            case 2:\r\n               this.findMaze(recursiveBacktracker,'normal-node')\r\n                break;\r\n            case 3:\r\n                this.findMaze(prim,'normal-node')\r\n            break;\r\n            case 4:\r\n                this.findMaze(spiral,'wall')\r\n                    break;\r\n            case 5:\r\n                 newGrid=randomMaze(this.state.grid,'wall')\r\n                 this.setState({grid:newGrid})\r\n                break;\r\n            case 6:\r\n                 newGrid=randomMaze(this.state.grid,'weight')\r\n                this.setState({grid:newGrid})\r\n                break;\r\n           \r\n          default:\r\n              break\r\n        }\r\n        \r\n      }\r\n      findMaze(mazeCallback,type){\r\n        this.clearWallsAndWeights(this.state.grid)\r\n        const startNode=getNodeByType(this.state.grid,'start')\r\n        const  finishNode=getNodeByType(this.state.grid,'finish')\r\n        const nodesToAnimate= mazeCallback(this.state.grid, startNode,finishNode)\r\n        this.animateMaze(nodesToAnimate,type)\r\n      }\r\n      animateMaze(nodesToAnimate,type) {\r\n        \r\n        for (let i = 1; i < nodesToAnimate.length; i++) {\r\n            \r\n          setTimeout(() => {\r\n            const node = nodesToAnimate[i];\r\n            if(node.type==='start'||node.type==='finish')return\r\n            const newGrid=getNewGridWithNewNodeType(this.state.grid,node.row,node.col,type)\r\n            this.setState({grid:newGrid})\r\n          },1);\r\n        }\r\n      }\r\n    clearWallsAndWeights(grid){\r\n        this.clearNodes(grid,'wall')\r\n        this.clearNodes(grid,'weight')\r\n    }\r\n\r\n    clearBoard(){\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\r\n            return;\r\n        }\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if(row === startNodeRow && col === startNodeCol){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node start-node\";\r\n                }\r\n                else if(row === finishNodeRow && col === finishNodeCol){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node finish-node\";\r\n                }\r\n                else {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n                }\r\n              }\r\n            const newGrid = initializeGrid();\r\n            this.setState({\r\n                grid: newGrid,\r\n                visualizingAlgorithm: false,\r\n                generatingMaze: false,\r\n            });\r\n        }\r\n    \r\n    clearPath(){\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\r\n            return;\r\n        }\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if(document.getElementById(`node-${row}-${col}`).className == \"node start-node visited node-shortest-path\"){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node start-node\";\r\n                }\r\n                \r\n                else if(document.getElementById(`node-${row}-${col}`).className == \"node finish-node visited node-shortest-path\"){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node finish-node\";\r\n                }\r\n                else if((document.getElementById(`node-${row}-${col}`).className == \"node visited\") || (document.getElementById(`node-${row}-${col}`).className == \"node visited node-shortest-path\")){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                } \r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    clearNodes(grid,type){\r\n        const newGrid=grid.slice()\r\n        for (const row of newGrid) {\r\n            for (const node of row) {\r\n            //    console.log(node)\r\n               if(node.type==type){\r\n                node.type=\"normal-node\"\r\n               \r\n               } \r\n            }\r\n          }\r\n        this.setState({grid:newGrid})\r\n    }\r\n  \r\n   \r\n\r\n    render(){        \r\n        const {grid} = this.state;\r\n        \r\n        return(\r\n          <div>\r\n            <div className=\"header\">\r\n                <div className=\"logo\"><span>Pathfiniding Visualizer</span></div>\r\n                <div className=\"dropdown\">\r\n                    <button className=\"dropbtn\"><span>Algorithms</span>\r\n                        <i className=\"fa fa-caret-down\"></i>\r\n                    </button>\r\n                    <div className=\"dropdown-content\">\r\n                        <button onClick={() => this.visualizeAlgorithm(1)}>Dijkstra</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(2)}>A*</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(3)}>Breadth First Search</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(4)}>Depth First Search</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(5)}>Greedy Best First Search</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(6)}>Bidirectional Greedy Search</button>\r\n                    </div>\r\n                    \r\n                </div>\r\n                <div className=\"dropdown\">\r\n                    <button className=\"dropbtn\"><span>Mazes</span>\r\n                        <i className=\"fa fa-caret-down\"></i>\r\n                    </button>\r\n                    <div className=\"dropdown-content\">\r\n                        <button onClick={() => this.visualizeMaze(1)}>Recursive Division maze</button>\r\n                        <button onClick={() => this.visualizeMaze(2)}>Recursive Backtracker</button>\r\n                        <button onClick={() => this.visualizeMaze(3)}>Randomized Prim's algorithm</button>\r\n                        <button onClick={() => this.visualizeMaze(4)}>Spriral Maze</button>\r\n                        <button onClick={() => this.visualizeMaze(5)}>Random Wall Maze</button>\r\n                        <button onClick={() => this.visualizeMaze(6)}>Random Weight Maze</button>\r\n                    </div>\r\n                </div>\r\n                <div className=\"dropdown\">\r\n                <button className=\"dropbtn\"><span>Speed</span>\r\n                        <i className=\"fa fa-caret-down\"></i>\r\n                    </button>\r\n                    <div className=\"dropdown-content\">\r\n                        <button onClick={()=>changeAlgoritmSpeed(125)}>Slow</button>\r\n                        <button onClick={()=>changeAlgoritmSpeed(50)}>Medium</button>\r\n                        <button onClick={()=>changeAlgoritmSpeed(10)}>Fast</button>\r\n                    </div>\r\n                </div>\r\n                <button className=\"clear-walls\" onClick={()=>this.clearWallsAndWeights(this.state.grid)}>Clear Walls & Weights </button>\r\n                <button className=\"clear-walls\" onClick={()=>this.clearBoard()}>Clear Board </button>\r\n                <button className=\"clear-walls\" onClick={()=>this.clearPath()}>Clear Path </button>\r\n\r\n            </div>\r\n\r\n\r\n            <div id='mainGrid'>\r\n                <div id='mainText'>\r\n                    <ul>\r\n                    <li>\r\n                        <div class=\"start\"></div>Start Node</li>\r\n                    <li>\r\n                        <div class=\"target\"></div>Target Node</li>\r\n                    <li id=\"weightLegend\">\r\n                        <div class=\"borderlessWeight\"></div>Weight Node</li>\r\n                    <li>\r\n                        <div class=\"unvisited\"></div>Unvisited Node</li>\r\n                    <li>\r\n                        <div class=\"visited\"></div>Visited Nodes</li>\r\n                    <li>\r\n                        <div class=\"shortest-path\"></div>Shortest-path Node</li>\r\n                    <li>\r\n                        <div class=\"wall\"></div>Wall Node</li>\r\n                    </ul>\r\n                </div>\r\n                <div id=\"algorithmDescriptor\">Pick up an algorithm and visualize it!</div>\r\n            </div>\r\n\r\n\r\n            <table className=\"grid\">\r\n                {grid.map((row, rowIdx) => {\r\n                    return (\r\n                    <tr key={rowIdx}>\r\n                        {row.map((node, nodeIdx) => {\r\n                            const{row,col,type,isVisited,distance,gScore,fScore,hScore,closed}=node\r\n                        \r\n                        return (\r\n                            <Node \r\n                            key={nodeIdx}\r\n                            row={row}\r\n                            col={col}\r\n                            type={type}\r\n                            //isWall={isWall} comment Me\r\n                          \r\n                            isVisited={isVisited}\r\n                            distance={distance}\r\n                            gScore={gScore}\r\n                            fScore={fScore}\r\n                            hScore={hScore}\r\n                            closed={closed}\r\n                            onMouseDown={(row, col,type) => this.handleMouseDown(row, col,type)}\r\n                            onMouseEnter={(row, col,type) => this.handleMouseEnter(row, col,type)} \r\n                            onMouseUp={() => this.handleMouseUp()} \r\n                            onMouseLeave={()=>this.handleMouseLeave(row,col,type)}\r\n                         \r\n                            ></Node>\r\n                        );\r\n                        })}\r\n                    </tr>\r\n                    );\r\n                })}\r\n                </table>\r\n            </div>\r\n        )\r\n    }\r\n   \r\n}\r\nconst initializeGrid=()=>{\r\n    const grid=[]\r\n    for (let row = 0; row < 21; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < 60; col++) {\r\n          currentRow.push(getNode(row,col));\r\n        }\r\n        grid.push(currentRow);\r\n      }\r\n      return grid\r\n}\r\nconst getNode=(row,col)=>{\r\n\r\n    const type=row===startNodeRow&&col===startNodeCol?'start':\r\n    row===finishNodeRow&&col===finishNodeCol?'finish':'normal-node'\r\n\r\n    return{\r\n        row,\r\n        col,\r\n        type,\r\n        weightValue:1,\r\n        isVisited: false,\r\n        distance:Infinity,//djkstra\r\n        gScore:Infinity,//astar\r\n        fScore:Infinity,//astar\r\n        hScore:null,//astar\r\n        closed:false\r\n    }\r\n}\r\n\r\nconst getNewGridWithNewNodeType = (grid, row, col,newType) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n \r\n  const newNode = {\r\n    ...node,\r\n    // isWall:!node.isWall, \r\n    type:newType,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n//This function iterates trought the array and reuturns a node with a given type comment Me\r\nconst getNodeByType =(grid,givenType)=>{\r\n  \r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n           if(node.type===givenType){\r\n               return node;\r\n           }\r\n        }\r\n      }\r\n}\r\n\r\n\r\nfunction changeAlgoritmSpeed(speed){\r\n    algorithmSpeed=speed\r\n}\r\n","\nimport PathfindingVisulizer from './PathfindingVisualizer/PathfindingVisualizer'\n\nfunction App() {\n  return (\n   <PathfindingVisulizer></PathfindingVisulizer>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}