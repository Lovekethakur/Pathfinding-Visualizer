{"version":3,"sources":["PathfindingVisualizer/Node.jsx","pathfinding algoritms/dijkstra.js","pathfinding algoritms/astar.js","pathfinding algoritms/bfs.js","pathfinding algoritms/dfs.js","pathfinding algoritms/greedy.js","pathfinding algoritms/bidirectionalSearch.js","maze algoritms/randomMaze.js","maze algoritms/recursiveMaze.js","maze algoritms/recursiveBacktracker.js","maze algoritms/spriralMaze.js","maze algoritms/prim.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","row","type","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unVisitedNodes","nodes","node","push","getAllNodes","length","sort","nodeOne","nodeTwo","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getShortestDijkstraPath","nodesInShortestPathOrder","currentNode","unshift","astar","gScore","hScore","getManhattanDistance","openSet","fScore","console","log","closed","getNeighbors","tentativeGscoreToNeighbor","isInSet","set","i","currentNodeRow","currentNodeCol","finishNodeRow","finishNodeCol","Math","abs","getShortestAstarPath","bfs","structure","visitedNodes","name","getShortestBFSPath","dfs","unvisitedNodes","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","neighbours","neighbour","getShortestDFSPath","greedy","getShortestGreedyPath","isNeighbour","closestNodeStart","closestNodeFinish","rowStart","colStart","rowFinish","colFinish","getNeighbours","manhattenDistance","nodeA","nodeB","neighbourNotInUnvisitedNodes","randomMaze","random","weightValue","recursiveDivisionMaze","nodesToAnimate","isPassage","map","cell","addToArray","index","reverse","lastRow","lastCol","orientation","chooseOrientation","devide","firstRow","firstCol","width","height","firstValidRow","lastValidRow","firstValidCol","lastValidCol","validWidth","validHeight","passageIdx","rowIdxToBeWall","floor","forEach","colIdxToBeWall","idx","array","recursiveBacktracker","visited","nodesToRemoveWall","currentRow","currentCol","stack","next","getRBNeighbors","nextRow","nextCol","wall","getCellBeetween","pop","row1","col1","row2","col2","possibleNeighbors","spiral","prim","mazeSpeed","isWall","frontiersList","frontiers","getFrontiers","selectedIdx","getNeighborsPrime","neighborRow","neighborCol","splice","algorithmSpeed","wIsPressed","PathfinidingVisualizer","animateShortestPath1","setState","visualizingAlgorithm","setTimeout","document","getElementById","state","mouseIsPressed","nodeToChange","addEventListener","event","key","initializeGrid","newGrid","getNewGridWithNewNodeType","algorithm","findPath","clearNodes","visualizeBidirectionalGreedySearch","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesFinish","visitedNodesInOrderFinish","a","b","totalDistance","bidirectionalGreedySearch","getNodeByType","isShortedPath","getNodesInShortestPathOrderBidirectionalGreedySearch","animateBidirectionalAlgorithm","len","max","getVisitedNodesInOrder","undefined","nodeComponentA","classList","add","nodeComponentB","algorithmCallback","getShortestPathCallback","nodeInShortestPath","animateAlgorithm","animateShortestPath","nodeComponent","findMaze","mazeCallback","clearWallsAndWeights","animateMaze","slice","generatingMaze","newNode","onClick","visualizeAlgorithm","visualizeMaze","changeAlgoritmSpeed","clearBoard","clearPath","class","rowIdx","nodeIdx","isPath","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseLeave","getNode","newType","givenType","speed","n","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.5f648348.chunk.js","sourcesContent":["import './Node.css';\r\nimport React,{Component} from 'react'\r\n\r\nexport default class Node extends Component{\r\n  \r\n    render(){\r\n        const {\r\n            col,\r\n            row,\r\n            type,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            onMouseLeave\r\n          } = this.props;\r\n\r\n        const extraClassName=type==='start'?'start-node':\r\n                             type==='finish'?'finish-node':\r\n                             type==='wall'?'wall-node':\r\n                             type==='weight'?'weight-node':\r\n                             \"\"\r\n                             \r\n\r\n        \r\n                           \r\n        return ( <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`} \r\n        onMouseDown={()=>onMouseDown(row,col,type)}\r\n        onMouseEnter={()=>onMouseEnter(row,col,type)}\r\n        onMouseUp={()=>onMouseUp()}\r\n        onMouseLeave={()=>onMouseLeave()}\r\n        ></td>)\r\n        \r\n    }\r\n}","export function dijkstra(grid,startNode,finishNode){ \r\n\r\n   const visitedNodesInOrder=[]\r\n   startNode.distance=0\r\n   const unVisitedNodes=getAllNodes(grid)\r\n   \r\n   \r\n\r\n   while(!!unVisitedNodes.length){\r\n       sortNodesByDistance(unVisitedNodes)\r\n       const closestNode = unVisitedNodes.shift();\r\n       if(closestNode.type==='wall')continue\r\n       if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n       \r\n       closestNode.isVisited=true\r\n       visitedNodesInOrder.push(closestNode);\r\n\r\n       updateUnvisitedNeighbors(closestNode, grid);\r\n       if(closestNode===finishNode)return visitedNodesInOrder;\r\n   }\r\n}\r\nfunction getAllNodes(grid){\r\n    let nodes=[]\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            nodes.push(node)\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      if(neighbor.type==='weight'){\r\n        neighbor.distance=node.distance+5\r\n      }else{\r\n        neighbor.distance=node.distance+1\r\n      }\r\n     \r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n \r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\nfunction sortNodesByDistance(nodes){\r\n    nodes.sort((nodeOne, nodeTwo) => nodeOne.distance - nodeTwo.distance);\r\n}\r\nexport function getShortestDijkstraPath(finishNode) {\r\n  \r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","export function astar(grid,startNode,finishNode){\r\n\r\n  const visitedNodesInOrder=[]\r\n  //gScore is the distance from a node to the startnode\r\n  startNode.gScore=0\r\n  //hScore is the distance from a node to the finish node\r\n  startNode.hScore=getManhattanDistance(startNode,finishNode)\r\n\r\n  const openSet=[]\r\n  openSet.push(startNode)\r\n  \r\n\r\n  while(openSet.length > 0){\r\n    \r\n    sortNodesByFscore(openSet)\r\n    \r\n    var currentNode=openSet.shift()\r\n    // console.log(openSet)\r\n    console.log(currentNode)\r\n    visitedNodesInOrder.push(currentNode)\r\n\r\n    if(currentNode===finishNode)return visitedNodesInOrder\r\n    \r\n      // openSet.splice(lowestFScore,1)\r\n    \r\n    \r\n    currentNode.closed=true\r\n    for(let neighbor of getNeighbors(currentNode,grid)){\r\n      // console.log(neighbor.closed)\r\n\r\n      if(neighbor.type==='wall')continue\r\n      if(neighbor.closed)continue\r\n\r\n      let tentativeGscoreToNeighbor\r\n      if(neighbor.type==='weight'){\r\n        tentativeGscoreToNeighbor=currentNode.gScore+10\r\n      }else{\r\n        tentativeGscoreToNeighbor=currentNode.gScore+1\r\n      }\r\n\r\n      if(tentativeGscoreToNeighbor<neighbor.gScore){\r\n        // console.log(neighbor)\r\n        neighbor.gScore=tentativeGscoreToNeighbor\r\n        neighbor.hScore=getManhattanDistance(neighbor,finishNode)\r\n        neighbor.fScore = neighbor.gScore + neighbor.hScore;\r\n        neighbor.previousNode = currentNode;\r\n        // console.log(openSet)\r\n        if (!isInSet(neighbor, openSet)) {\r\n          openSet.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    \r\n  }\r\n  \r\n  return visitedNodesInOrder\r\n}\r\nfunction sortNodesByFscore(nodes){\r\n  nodes.sort((nodeOne, nodeTwo) => nodeOne.fScore - nodeTwo.fScore);\r\n}\r\n\r\nfunction isInSet(node, set) {\r\n  for (let i = set.length - 1; i >= 0; i++) {\r\n    if (set[i].row === node.row && set[i].col === node.col) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getManhattanDistance(currentNode, finishNode) {\r\n    const currentNodeRow=currentNode.row\r\n    const currentNodeCol=currentNode.col\r\n    const finishNodeRow=finishNode.row\r\n    const finishNodeCol=finishNode.col\r\n    \r\n    const manhattanDistance= Math.abs(currentNodeCol-finishNodeCol)+Math.abs(currentNodeRow-finishNodeRow)\r\n    \r\n    return manhattanDistance\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors\r\n}\r\nexport function getShortestAstarPath(finishNode) {\r\n  \r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n","export function bfs(grid,startNode,finishNode){\r\n    const structure = [];\r\n    const visitedNodes = [];\r\n    startNode.isVisited = true;\r\n    structure.push(startNode);\r\n  \r\n    while (structure.length>0) {\r\n    \r\n      let currentNode = structure.shift()\r\n    //   console.log(queue)\r\n       visitedNodes.push(currentNode);\r\n      if (currentNode === finishNode) {\r\n        // console.log(visitedNodes)\r\n        return visitedNodes;\r\n      }\r\n      // console.log(getNeighbors(currentNode,grid))\r\n      for (let neighbor of getNeighbors(currentNode,grid) ){\r\n        if (neighbor.type==='wall') {\r\n          continue;\r\n        }\r\n       \r\n        if(neighbor.isVisited===false){\r\n          neighbor.isVisited = true;\r\n          neighbor.previousNode = currentNode;\r\n          structure.push(neighbor);\r\n        }\r\n        \r\n      }\r\n    }\r\n    return visitedNodes\r\n}\r\n\r\nfunction getNeighbors(node,grid,name){\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n \r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  \r\n\r\n    \r\n  return neighbors;\r\n}\r\nexport function getShortestBFSPath(finishNode){\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;  \r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n","export function dfs(grid,startNode,finishNode){\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n      }\r\n    // console.log(\"hey\");\r\n    const visitedNodesInOrder = [];\r\n    const unvisitedNodes = [];\r\n      unvisitedNodes.push(startNode);\r\n      while (unvisitedNodes.length !== 0) {\r\n        let closestNode = unvisitedNodes.shift();\r\n        if (closestNode.type=== \"wall\") continue;\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n        visitedNodesInOrder.push(closestNode);\r\n        closestNode.isVisited = true;\r\n        let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\r\n        for (let unvisitedNeighbour of unvisitedNeighbours) {\r\n          unvisitedNeighbour.previousNode = closestNode;\r\n          unvisitedNodes.unshift(unvisitedNeighbour);\r\n        }\r\n      }\r\n      return visitedNodesInOrder;\r\n}\r\n\r\n\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n    // console.log(\"No\");\r\n    const neighbours = [];\r\n    const { row, col } = node;\r\n    if (col > 0) neighbours.push(grid[row][col - 1]);\r\n    if (row > 0) neighbours.push(grid[row - 1][col]);\r\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n\r\n    return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n  }\r\n\r\nexport function getShortestDFSPath(finishNode){\r\n    // console.log(\"hello\");\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n","export function greedy(grid,startNode,finishNode){ \r\n\r\n    const visitedNodesInOrder=[]\r\n    startNode.distance=getManhattanDistance(startNode,finishNode)\r\n    const unVisitedNodes=getAllNodes(grid)\r\n    \r\n    \r\n \r\n    while(!!unVisitedNodes.length){\r\n        sortNodesByDistance(unVisitedNodes)\r\n        const closestNode = unVisitedNodes.shift();\r\n        if(closestNode.type==='wall' || closestNode.type==='weight')continue\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited=true\r\n        visitedNodesInOrder.push(closestNode);\r\n \r\n        updateUnvisitedNeighbors(closestNode, grid,finishNode);\r\n        if(closestNode===finishNode)return visitedNodesInOrder\r\n    }\r\n }\r\n function getAllNodes(grid){\r\n     let nodes=[]\r\n     for(const row of grid){\r\n         for(const node of row){\r\n             nodes.push(node)\r\n         }\r\n     }\r\n     return nodes;\r\n }\r\n function updateUnvisitedNeighbors(node, grid,finishNode) {\r\n     const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n     for (const neighbor of unvisitedNeighbors) {\r\n         neighbor.distance=getManhattanDistance(neighbor,finishNode)\r\n      \r\n       neighbor.previousNode = node;\r\n     }\r\n   }\r\n  \r\n function getUnvisitedNeighbors(node, grid) {\r\n   const neighbors = [];\r\n   const {col, row} = node;\r\n   if (row > 0) neighbors.push(grid[row - 1][col]);\r\n   if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n   if (col > 0) neighbors.push(grid[row][col - 1]);\r\n   if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n   return neighbors.filter(neighbor => !neighbor.isVisited);\r\n }\r\n function sortNodesByDistance(nodes){\r\n     nodes.sort((nodeOne, nodeTwo) => nodeOne.distance - nodeTwo.distance);\r\n }\r\n function getManhattanDistance(currentNode, finishNode) {\r\n    const currentNodeRow=currentNode.row\r\n    const currentNodeCol=currentNode.col\r\n    const finishNodeRow=finishNode.row\r\n    const finishNodeCol=finishNode.col\r\n    \r\n    const manhattanDistance= Math.abs(currentNodeCol-finishNodeCol)+Math.abs(currentNodeRow-finishNodeRow)\r\n    \r\n    return manhattanDistance\r\n}\r\n export function getShortestGreedyPath(finishNode) {\r\n   \r\n     const nodesInShortestPathOrder = [];\r\n     let currentNode = finishNode;\r\n     while (currentNode !== null) {\r\n       nodesInShortestPathOrder.unshift(currentNode);\r\n         currentNode = currentNode.previousNode;\r\n       }\r\n       return nodesInShortestPathOrder;\r\n     }\r\n ","export function bidirectionalGreedySearch(grid, startNode, finishNode) {\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n      return false;\r\n    }\r\n    let unvisitedNodesStart = [];\r\n    let visitedNodesInOrderStart = [];\r\n    let unvisitedNodesFinish = [];\r\n    let visitedNodesInOrderFinish = [];\r\n    startNode.distance = 0;\r\n    finishNode.distance = 0;\r\n    unvisitedNodesStart.push(startNode);\r\n    unvisitedNodesFinish.push(finishNode);\r\n  \r\n    while (\r\n      unvisitedNodesStart.length !== 0 &&\r\n      unvisitedNodesFinish.length !== 0\r\n    ) {\r\n      unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\r\n      unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\r\n      let closestNodeStart = unvisitedNodesStart.shift();\r\n      let closestNodeFinish = unvisitedNodesFinish.shift();\r\n  \r\n      closestNodeStart.isVisited = true;\r\n      closestNodeFinish.isVisited = true;\r\n      visitedNodesInOrderStart.push(closestNodeStart);\r\n      visitedNodesInOrderFinish.push(closestNodeFinish);\r\n      if (isNeighbour(closestNodeStart, closestNodeFinish)) {\r\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n      }\r\n  \r\n      //Start side search\r\n      let neighbours = getNeighbours(closestNodeStart, grid);\r\n      for (let neighbour of neighbours) {\r\n        if(neighbour.type==='wall' || neighbour.type==='weight') continue;\r\n        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n          visitedNodesInOrderStart.push(closestNodeStart);\r\n          visitedNodesInOrderFinish.push(neighbour);\r\n          return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n        }\r\n        let distance = closestNodeStart.distance + 1;\r\n        //f(n) = h(n)\r\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n          unvisitedNodesStart.unshift(neighbour);\r\n          neighbour.distance = distance;\r\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n          neighbour.previousNode = closestNodeStart;\r\n        } else if (distance < neighbour.distance) {\r\n          neighbour.distance = distance;\r\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n          neighbour.previousNode = closestNodeStart;\r\n        }\r\n      }\r\n  \r\n      //Finish side search\r\n      neighbours = getNeighbours(closestNodeFinish, grid);\r\n      for (let neighbour of neighbours) {\r\n        if(neighbour.type==='wall' || neighbour.type==='weight') continue;\r\n        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n          visitedNodesInOrderStart.push(closestNodeFinish);\r\n          visitedNodesInOrderStart.push(neighbour);\r\n          return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n        }\r\n        let distance = closestNodeFinish.distance + 1;\r\n        //f(n) = h(n)\r\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n          unvisitedNodesFinish.unshift(neighbour);\r\n          neighbour.distance = distance;\r\n          neighbour.totalDistance = manhattenDistance(neighbour, startNode);\r\n          neighbour.previousNode = closestNodeFinish;\r\n        } else if (distance < neighbour.distance) {\r\n          neighbour.distance = distance;\r\n          neighbour.totalDistance = manhattenDistance(neighbour, startNode);\r\n          neighbour.previousNode = closestNodeFinish;\r\n        }\r\n      }\r\n    }\r\n    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\r\n  }\r\n  \r\n  function isNeighbour(closestNodeStart, closestNodeFinish) {\r\n    let rowStart = closestNodeStart.row;\r\n    let colStart = closestNodeStart.col;\r\n    let rowFinish = closestNodeFinish.row;\r\n    let colFinish = closestNodeFinish.col;\r\n    if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\r\n    if (rowFinish === rowStart && colFinish === colStart + 1) return true;\r\n    if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\r\n    if (rowFinish === rowStart && colFinish === colStart - 1) return true;\r\n    return false;\r\n  }\r\n  \r\n  function getNeighbours(node, grid) {\r\n    let neighbours = [];\r\n    let { row, col } = node;\r\n    if (row > 0) neighbours.push(grid[row - 1][col]);\r\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col > 0) neighbours.push(grid[row][col - 1]);\r\n    return neighbours.filter(\r\n      (neighbour) => !neighbour.isVisited\r\n    );\r\n  }\r\n  \r\n  function manhattenDistance(nodeA, nodeB) {\r\n    let x = Math.abs(nodeA.row - nodeB.row);\r\n    let y = Math.abs(nodeA.col - nodeB.col);\r\n    return x + y;\r\n  }\r\n  \r\n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n    for (let node of unvisitedNodes) {\r\n      if (node.row === neighbour.row && node.col === neighbour.col) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  export function getNodesInShortestPathOrderBidirectionalGreedySearch(\r\n    nodeA,\r\n    nodeB\r\n  ) {\r\n    let nodesInShortestPathOrder = [];\r\n    let currentNode = nodeB;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.push(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n      }\r\n    currentNode = nodeA;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }","export default function randomMaze(grid,type){\r\n    for(let row of grid){\r\n        for(let node of row){\r\n           \r\n            if(node.type ==='finish'||node.type ==='start')continue\r\n            let random = Math.random();\r\n\t\t\tlet randomTwo =type==='wall'? 0.35: 0.25;\r\n\t\t\tif (random < randomTwo ) {\r\n                // console.log(node)\r\n                // console.log(node.type)\r\n               node.type=type\r\n               if(type==='weight'){\r\n                node.weightValue=15\r\n            }\r\n            }\r\n            \r\n        }\r\n    }\r\n  return grid\r\n}","export default function recursiveDivisionMaze (grid){\r\n    console.log('rd start');\r\n    const nodesToAnimate = []\r\n\r\n    const isPassage = grid.map(row=>row.map(cell=>false))\r\n\r\n    //make edges wall. just for more beautiful look\r\n    grid[0].map(cell=>addToArray(nodesToAnimate,cell));\r\n\r\n    grid.map(row=>row.map((node,index)=> {\r\n        if(index===grid[0].length-1){\r\n            if(node.type!=='start'||node.type!=='finish'){\r\n              addToArray(nodesToAnimate,node)\r\n            }\r\n        }\r\n    }));\r\n\r\n    grid[grid.length-1].reverse().map(cell=>addToArray(nodesToAnimate,cell));\r\n\r\n    grid.map(row=>row.map((cell, index)=> index===0  && addToArray(nodesToAnimate,cell)));\r\n\r\n\r\n    let firstRow = 1;\r\n    let lastRow = grid.length - 2;\r\n    let firstCol = 1;\r\n    let lastCol = grid[0].length - 2;\r\n\r\n   let orientation = chooseOrientation(grid,firstRow,lastRow,firstCol,lastCol);\r\n    devide(grid,firstRow,lastRow,firstCol,lastCol,orientation,nodesToAnimate,isPassage);\r\n\r\n    \r\n    \r\n\r\n    return nodesToAnimate\r\n}\r\n\r\n\r\n//-------------------------\r\n//   Recursive Devision Helper Functions\r\n//---------------------------\r\n\r\n\r\n//#1-choose orientation\r\nconst chooseOrientation = (grid,firstRow,lastRow,firstCol,lastCol) =>{\r\n    let width = lastCol - firstCol;\r\n    let height = lastRow - firstRow;\r\n    if(width>height){\r\n        return 'Vertical'\r\n    }else if(height>width){\r\n        return 'Horizontal'\r\n    }else{\r\n        const num = Math.random();\r\n        return (num<0.5) ? 'Vertical' : 'Horizontal'\r\n    }\r\n}\r\n\r\n\r\n//#2- devide\r\nconst devide = (grid,firstRow,lastRow,firstCol,lastCol,orientation,nodesToAnimate,isPassage) =>{\r\n    let width = lastCol - firstCol + 1;\r\n    let height = lastRow - firstRow + 1;\r\n\r\n    let firstValidRow = firstRow ;\r\n    let lastValidRow = lastRow;\r\n    let firstValidCol = firstCol;\r\n    let lastValidCol = lastCol;\r\n\r\n\r\n    if(orientation==='Horizontal'){\r\n        firstValidRow += 1\r\n        lastValidRow -= 1\r\n    }else{\r\n        firstValidCol += 1\r\n        lastValidCol -= 1\r\n    }\r\n    \r\n\r\n    let validWidth = lastValidCol - firstValidCol + 1;\r\n    let validHeight = lastValidRow - firstValidRow + 1;\r\n    \r\n\r\n    if(width<2 || height<2 || validHeight<1 || validWidth<1) return;\r\n\r\n    if(orientation==='Horizontal'){\r\n\r\n\r\n        let rowIdxToBeWall = Math.floor(Math.random()* validHeight) + firstValidRow;\r\n        //let passageIdx = Math.floor(Math.random() * validWidth) + firstValidCol;\r\n\r\n        let passageIdx;\r\n        if (isPassage[rowIdxToBeWall][firstCol-1]){\r\n\t\t\t passageIdx = firstCol;\r\n\t\t} else if (isPassage[rowIdxToBeWall][lastCol+1]){\r\n\t\t\t passageIdx = lastCol;\r\n\t\t} else {\r\n\t\t\t passageIdx = Math.random()>0.5 ? firstCol: lastCol; // random end assignment\r\n        }\r\n\r\n        grid[rowIdxToBeWall].forEach((node, index)=>{\r\n            if(node.type==='start'||node.type==='finish'){\r\n                isPassage[rowIdxToBeWall][index] = true;\r\n            }\r\n            if(isPassage[rowIdxToBeWall][index]) return\r\n            if(index< firstValidCol  || index>lastValidCol) return;\r\n            if(index===passageIdx){\r\n                isPassage[rowIdxToBeWall][index] = true;\r\n                return\r\n            }\r\n            \r\n             addToArray(nodesToAnimate,node)\r\n            \r\n        })\r\n\r\n        // upper side\r\n        let orientation = chooseOrientation(grid,firstRow,rowIdxToBeWall-1,firstCol,lastCol);\r\n        devide(grid,firstRow,rowIdxToBeWall-1,firstCol,lastCol,orientation,nodesToAnimate,isPassage);\r\n\r\n        //Bottom side\r\n        orientation = chooseOrientation(grid,rowIdxToBeWall+1,lastRow,firstCol,lastCol);\r\n        devide(grid,rowIdxToBeWall+1,lastRow,firstCol,lastCol,orientation,nodesToAnimate,isPassage);\r\n\r\n\r\n    }else{\r\n\r\n        let colIdxToBeWall = Math.floor(Math.random()* validWidth ) + firstValidCol;\r\n        //let passageIdx = Math.floor(Math.random() * validHeight) + firstValidRow;\r\n\r\n\r\n        let passageIdx;\r\n        if (firstRow-1>=0 && isPassage[firstRow-1][colIdxToBeWall]){\r\n\t\t\tpassageIdx = firstRow;\r\n\t\t} else if (lastRow+1<grid.length && isPassage[lastRow+1][colIdxToBeWall]){\r\n\t\t\tpassageIdx = lastRow;\r\n\t\t} else {\r\n\t\t\tpassageIdx = Math.random()>0.5 ? firstRow: lastRow; // random end assignment\r\n\t\t}\r\n\r\n        grid.forEach((row, index)=>{\r\n            \r\n            if (index<firstValidRow || index>lastValidRow) return;\r\n            if (index === passageIdx){\r\n                isPassage[index][colIdxToBeWall] = true;\r\n                return;\r\n            }\r\n\r\n            row.forEach((node, idx)=>{\r\n\r\n                if(node.type==='start'||node.type==='finish'){\r\n                    isPassage[index][idx] = true;\r\n                }\r\n                if(isPassage[index][idx]) return;\r\n                \r\n                idx===colIdxToBeWall && nodesToAnimate.push(node);\r\n        })});\r\n\r\n\r\n        //left side\r\n        orientation = chooseOrientation(grid,firstRow,lastRow,firstCol,colIdxToBeWall-1);\r\n        devide(grid,firstRow,lastRow,firstCol,colIdxToBeWall - 1 ,orientation,nodesToAnimate,isPassage);\r\n\r\n\r\n        //right side\r\n        orientation = chooseOrientation(grid,firstRow,lastRow,colIdxToBeWall + 1,lastCol);\r\n        devide(grid,firstRow,lastRow,colIdxToBeWall + 1, lastCol ,orientation,nodesToAnimate,isPassage);\r\n\r\n    }\r\n\r\n}\r\nfunction addToArray(array,node){\r\n    if(node.type!=='start'&&node.type!=='finish'){\r\n        array.push(node)        \r\n    }\r\n}\r\n\r\n","\r\nexport default function recursiveBacktracker (grid){\r\n    \r\n    \r\n    \r\n    grid.map(row=>row.map((node)=> {\r\n        \r\n            if(node.type==='start'||node.type==='finish')return\r\n              node.type='wall'\r\n            \r\n        \r\n    }));\r\n\r\n    const visited = grid.map(row=>row.map(cell=>false));\r\n\r\n    const nodesToRemoveWall = []\r\n\r\n    let [currentRow,currentCol] = [0,0];\r\n    \r\n    visited[currentRow][currentCol] = true;\r\n\r\n    let stack = []\r\n\r\n    \r\n    while(true){\r\n        //counter += 1;\r\n\r\n        nodesToRemoveWall.push(grid[currentRow][currentCol]);\r\n\r\n    \r\n    let next = getRBNeighbors(currentRow,currentCol, grid,visited);\r\n\r\n    if(next){\r\n        stack.push(next);\r\n\r\n        let [nextRow,nextCol] = next;\r\n\r\n        visited[nextRow][nextCol] = true;\r\n\r\n        let wall = getCellBeetween(currentRow, currentCol,nextRow,nextCol,grid);\r\n\r\n        nodesToRemoveWall.push(wall);\r\n\r\n        currentRow = nextRow;\r\n        currentCol = nextCol;\r\n\r\n    }else{\r\n\r\n        if(stack.length>0){\r\n\r\n            next = stack.pop();\r\n\r\n            let [nextRow, nextCol] = next;\r\n\r\n            currentRow=nextRow;\r\n            currentCol = nextCol;\r\n        }else{\r\n            break;\r\n        }\r\n       \r\n    }\r\n    }\r\n\r\n    \r\n    \r\n\r\n    return nodesToRemoveWall;\r\n\r\n}\r\nconst getCellBeetween = (row1,col1,row2,col2,grid)=>{\r\n    if(row1===row2){\r\n        if(col1>col2){\r\n            return grid[row1][col2+1]\r\n        }else{\r\n            return grid[row1][col1+1]\r\n        }\r\n        \r\n    }else if(col1===col2){\r\n        if(row2>row1){\r\n            return grid[row1+1][col1]\r\n        }else{\r\n            return grid[row2+1][col1]\r\n        }\r\n    }\r\n}\r\n\r\nconst getRBNeighbors = (currentRow,currentCol,grid,visited)=>{\r\n\r\n    let possibleNeighbors = [\r\n        [currentRow+2,currentCol],\r\n        [currentRow-2, currentCol],\r\n        [currentRow, currentCol+2],\r\n        [currentRow, currentCol-2]\r\n    ]\r\n\r\n\r\n    let neighbors = [];\r\n\r\n    for(let i=0;i<possibleNeighbors.length;i++){\r\n        let [row,col] = possibleNeighbors[i];\r\n        if(row<0 || row>grid.length-1 || col<0 || col>grid[0].length-1) continue;\r\n        if(visited[row][col]) continue;\r\n        neighbors.push([row,col])\r\n    }\r\n\r\n    if(neighbors.length>0){\r\n        const nextIdx = Math.floor(Math.random()*neighbors.length);\r\n        return neighbors[nextIdx];\r\n    }else{\r\n        return;\r\n    }\r\n\r\n}\r\n\r\n","export default function spiral (grid){\r\n    console.log('spiral start')\r\n    const nodesToAnimate = [];\r\n\r\n    let firstRow =0\r\n    let lastRow = grid.length-1;\r\n    let firstCol = 0;\r\n    let lastCol = grid[0].length-1;\r\n\r\n    while (lastRow-firstRow>2&& lastCol-firstRow>2){\r\n        for(let col=firstCol;col<lastCol;col++){\r\n            nodesToAnimate.push(grid[firstRow][col])\r\n            //console.log(grid[firstRow][col])\r\n        }\r\n        for(let row=firstRow;row<lastRow;row++){\r\n            nodesToAnimate.push(grid[row][lastCol])\r\n        }\r\n        for(let col=lastCol;col>firstCol;col--){\r\n            nodesToAnimate.push(grid[lastRow][col])\r\n        }\r\n        for(let row=lastRow;row>firstRow+2;row--){\r\n            nodesToAnimate.push(grid[row][firstCol+1])\r\n        }\r\n\r\n        nodesToAnimate.push(grid[firstRow+3][firstCol+2])\r\n        nodesToAnimate.push(grid[firstRow+3][firstCol+3])\r\n        firstRow += 3\r\n        lastRow -= 3\r\n        firstCol += 4\r\n        lastCol -=3\r\n    }\r\n   return nodesToAnimate\r\n}\r\n","export default function prim  (grid,mazeSpeed){\r\n    \r\n    let start;\r\n    let end;\r\n    grid.map((row,index)=>row.map((cell,idx)=>{\r\n        if(cell.type==='start'){\r\n            start = [index,idx];\r\n            return;\r\n        }else if(cell.type==='finish'){\r\n            end = [index,idx];\r\n            return;\r\n        }else{\r\n            cell.type='wall';\r\n        }\r\n        \r\n    }));\r\n\r\n    const isWall = grid.map(row=>row.map(cell=>true));\r\n    const visited = grid.map(row=>row.map(cell=>false));\r\n\r\n    let currentRow = Math.floor(Math.random()*grid.length);\r\n    let currentCol = Math.floor(Math.random()*grid[0].length);\r\n\r\n    const frontiersList = [];\r\n\r\n    const nodesToRemoveWall = [];\r\n\r\n    nodesToRemoveWall.push(grid[currentRow][currentCol]);\r\n\r\n    isWall[currentRow][currentCol] = false;\r\n\r\n    let frontiers = getFrontiers(grid,currentRow,currentCol,isWall,visited);\r\n    \r\n\r\n    for(let i=0; i<frontiers.length; i++){\r\n        frontiersList.push(frontiers[i])\r\n        let [row,col] = frontiers[i]\r\n        visited[row][col] = true;\r\n    }\r\n   \r\n    while (frontiersList.length>0){\r\n       \r\n        let selectedIdx = Math.floor(Math.random()*frontiersList.length);\r\n\r\n        let [currentRow,currentCol] = frontiersList[selectedIdx];\r\n\r\n        let neighbors = getNeighborsPrime(grid,currentRow,currentCol,isWall);\r\n\r\n        let randomNeighborIdx = Math.floor(Math.random()*neighbors.length);\r\n\r\n        let neighbor = neighbors[randomNeighborIdx];\r\n\r\n        let [neighborRow,neighborCol] = neighbor;\r\n\r\n        let wall = getCellBeetween(neighborRow,neighborCol,currentRow,currentCol,grid);\r\n\r\n        nodesToRemoveWall.push(wall);\r\n\r\n        nodesToRemoveWall.push(grid[currentRow][currentCol]);\r\n\r\n        isWall[neighborRow][neighborCol] = false;\r\n        isWall[currentRow][currentCol] =false;\r\n\r\n        frontiers = getFrontiers(grid,currentRow,currentCol,isWall,visited);\r\n\r\n        for(let i=0; i<frontiers.length;i++){\r\n            frontiersList.push(frontiers[i]);\r\n            let [row,col] = frontiers[i]\r\n            visited[row][col] = true;\r\n        }\r\n\r\n        frontiersList.splice(selectedIdx,1)\r\n\r\n        }\r\n        return nodesToRemoveWall\r\n\r\n    }\r\n    const getFrontiers = (grid,currentRow,currentCol,isWall,visited)=>{\r\n        let possibleNeighbors = [\r\n            [currentRow,currentCol-2],\r\n            [currentRow, currentCol+2],\r\n            [currentRow-2, currentCol],\r\n            [currentRow+2,currentCol]\r\n        ]\r\n    \r\n        let frontiers=[]\r\n        for(let i=0; i<possibleNeighbors.length; i++){\r\n            let [row,col] = possibleNeighbors[i];\r\n            if(row>=0 && row<grid.length && col>=0 && col<grid[0].length){\r\n                if (isWall[row][col] && !visited[row][col]){\r\n                    frontiers.push([row,col])\r\n                }\r\n               \r\n            }\r\n        }\r\n    \r\n        return frontiers;\r\n    }\r\n    \r\n    const getNeighborsPrime = (grid,currentRow,currentCol,isWall)=>{\r\n        let possibleNeighbors = [\r\n            [currentRow,currentCol-2],\r\n            [currentRow, currentCol+2],\r\n            [currentRow-2, currentCol],\r\n            [currentRow+2,currentCol]\r\n        ]\r\n    \r\n        let neighbors=[]\r\n        for(let i=0; i<possibleNeighbors.length; i++){\r\n            let [row,col] = possibleNeighbors[i];\r\n            if(row>=0 && row<grid.length && col>=0 && col<grid[0].length){\r\n                if (isWall[row][col]){\r\n                    continue\r\n                }else{\r\n                    neighbors.push([row,col])\r\n                }\r\n               \r\n            }\r\n        }\r\n    \r\n        return neighbors;\r\n    }\r\n    \r\n    \r\n    \r\nconst getCellBeetween = (row1,col1,row2,col2,grid)=>{\r\n    if(row1===row2){\r\n        if(col1>col2){\r\n            return grid[row1][col2+1]\r\n        }else{\r\n            return grid[row1][col1+1]\r\n        }\r\n        \r\n    }else if(col1===col2){\r\n        if(row2>row1){\r\n            return grid[row1+1][col1]\r\n        }else{\r\n            return grid[row2+1][col1]\r\n        }\r\n    }\r\n}\r\n","import React, {Component} from 'react';\r\nimport './PathfindingVisualizer.css';\r\nimport Node from './Node'\r\n\r\nimport { dijkstra,getShortestDijkstraPath } from '../pathfinding algoritms/dijkstra';\r\nimport {astar ,getShortestAstarPath} from '../pathfinding algoritms/astar';\r\nimport {bfs,getShortestBFSPath} from '../pathfinding algoritms/bfs';\r\nimport {dfs,getShortestDFSPath} from '../pathfinding algoritms/dfs';\r\nimport {greedy,getShortestGreedyPath} from '../pathfinding algoritms/greedy';\r\nimport {bidirectionalGreedySearch,getNodesInShortestPathOrderBidirectionalGreedySearch,} from '../pathfinding algoritms/bidirectionalSearch';\r\nimport randomMaze from '../maze algoritms/randomMaze'\r\nimport  recursiveDivisionMaze  from '../maze algoritms/recursiveMaze';\r\nimport  recursiveBacktracker  from '../maze algoritms/recursiveBacktracker';\r\nimport spiral from '../maze algoritms/spriralMaze';\r\nimport prim from '../maze algoritms/prim';\r\n\r\nlet startNodeRow = 10;\r\nlet startNodeCol = 10;\r\nlet finishNodeRow = 10;\r\nlet finishNodeCol = 40;\r\nlet algorithmRunning=false\r\nlet algorithmSpeed=10;\r\nlet wIsPressed=false\r\n\r\nexport default class PathfinidingVisualizer extends Component{\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            grid:[],\r\n            mouseIsPressed:false,\r\n            nodeToChange:''\r\n            \r\n        }\r\n        document.addEventListener('keydown', function(event){\r\n            if(event.key===\"w\"){\r\n                wIsPressed=true\r\n            }\r\n          })\r\n          document.addEventListener('keyup', function(event){\r\n            if(event.key===\"w\"){\r\n               wIsPressed=false\r\n            }\r\n          })\r\n      \r\n    }\r\n    componentDidMount(){\r\n          const grid=initializeGrid()\r\n          this.setState({grid});\r\n         \r\n    }\r\n   \r\n    \r\n    handleMouseDown(row,col,type){\r\n      let newGrid\r\n      if(algorithmRunning)return\r\n      \r\n      switch (type) {\r\n          case 'normal-node':\r\n              if(wIsPressed){\r\n                  newGrid=getNewGridWithNewNodeType(this.state.grid,row,col,'weight')\r\n                  this.setState({grid: newGrid,mouseIsPressed:true,nodeToChange:'weight'})\r\n                  break \r\n              }else{\r\n                  newGrid=getNewGridWithNewNodeType(this.state.grid,row,col,'wall')\r\n                  this.setState({grid: newGrid,mouseIsPressed:true,nodeToChange:'wall'})\r\n              }\r\n              break;\r\n          case 'wall':\r\n              newGrid=getNewGridWithNewNodeType(this.state.grid,row,col,'normal-node')\r\n              this.setState({grid: newGrid,mouseIsPressed:true,nodeToChange:'normal-node'})\r\n              break;\r\n          case 'start':\r\n              this.setState({mouseIsPressed:true, nodeToChange:'start'})\r\n              \r\n              break;\r\n          case 'finish':\r\n              this.setState({mouseIsPressed:true, nodeToChange:'finish'})\r\n              break;\r\n          default:\r\n             \r\n              break;\r\n      }\r\n \r\n  }\r\n  handleMouseEnter(row,col,type){\r\n      if(algorithmRunning)return\r\n      if(!this.state.mouseIsPressed)return\r\n      let newGrid;\r\n      if(type==='wall'||type==='normal-node'){\r\n          newGrid = getNewGridWithNewNodeType(this.state.grid,row,col,this.state.nodeToChange)\r\n          \r\n          this.setState({grid: newGrid});\r\n      }\r\n    } \r\n  handleMouseUp(){\r\n      this.setState({mouseIsPressed: false});\r\n  }\r\n  handleMouseLeave(row,col,type){\r\n      let newGrid;\r\n      if(!this.state.mouseIsPressed)return\r\n      if((type==='start'||type==='finish')&&this.state.nodeToChange!=='wall'){\r\n        newGrid=getNewGridWithNewNodeType(this.state.grid,row,col,'normal-node');\r\n          this.setState({grid: newGrid});   \r\n      }\r\n      \r\n  }\r\n\r\n    visualizeAlgorithm(algorithm) {\r\n        switch (algorithm) {\r\n            case 0:\r\n                break;\r\n            case 1:\r\n                this.findPath(dijkstra,getShortestDijkstraPath);\r\n            break;\r\n            case 2:\r\n                this.findPath(astar,getShortestAstarPath,);\r\n            break;\r\n            case 3:\r\n                this.clearNodes(this.state.grid,'weight')\r\n                this.findPath(bfs,getShortestBFSPath)\r\n                break;\r\n            case 4:\r\n                this.clearNodes(this.state.grid,'weight');\r\n                this.findPath(dfs,getShortestDFSPath);\r\n                break;\r\n            case 5:\r\n                this.findPath(greedy,getShortestGreedyPath);\r\n            break;\r\n            case 6:\r\n                this.visualizeBidirectionalGreedySearch();\r\n            break;\r\n          default:\r\n              break\r\n        }\r\n      }\r\n     //bidirectional\r\n\r\n     visualizeBidirectionalGreedySearch() {\r\n        setTimeout(() => {\r\n          const { grid } = this.state;\r\n          let startNode = getNodeByType(this.state.grid,'start')\r\n          let finishNode =getNodeByType(this.state.grid,'finish')\r\n          const visitedNodesInOrder = bidirectionalGreedySearch(\r\n            grid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          const visitedNodesInOrderStart = visitedNodesInOrder[0];\r\n          const visitedNodesInOrderFinish = visitedNodesInOrder[1];\r\n          const isShortedPath = visitedNodesInOrder[2];\r\n          const nodesInShortestPathOrder = getNodesInShortestPathOrderBidirectionalGreedySearch(\r\n            visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\r\n            visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\r\n          );\r\n          this.animateBidirectionalAlgorithm(\r\n            visitedNodesInOrderStart,\r\n            visitedNodesInOrderFinish,\r\n            nodesInShortestPathOrder,\r\n            isShortedPath\r\n          );\r\n        }, algorithmSpeed);\r\n      }\r\n\r\n      animateBidirectionalAlgorithm(\r\n        visitedNodesInOrderStart,\r\n        visitedNodesInOrderFinish,\r\n        nodesInShortestPathOrder,\r\n        isShortedPath\r\n      ) {\r\n        let len = Math.max(\r\n          visitedNodesInOrderStart.length,\r\n          visitedNodesInOrderFinish.length+1\r\n        );\r\n        for (let i = 0; i <= len; i++) {\r\n          let nodeA = visitedNodesInOrderStart[i];\r\n          let nodeB = visitedNodesInOrderFinish[i];\r\n          if (i === visitedNodesInOrderStart.length) {\r\n            setTimeout(() => {\r\n              let visitedNodesInOrder = getVisitedNodesInOrder(\r\n                visitedNodesInOrderStart,\r\n                visitedNodesInOrderFinish\r\n              );\r\n              if (isShortedPath) {\r\n                this.animateShortestPath1(\r\n                  nodesInShortestPathOrder,\r\n                  visitedNodesInOrder\r\n                );\r\n              } else {\r\n                this.setState({ visualizingAlgorithm: false });\r\n              }\r\n            }, i * algorithmSpeed);\r\n            return;\r\n          }\r\n       \r\n            //visited nodes\r\n            if (nodeA !== undefined){\r\n                \r\n            const nodeComponentA=document.getElementById(`node-${nodeA.row}-${nodeA.col}`);\r\n        setTimeout(() => {\r\n            nodeComponentA.classList.add('node-visiting');\r\n        }, algorithmSpeed * (i - 0.8));\r\n          setTimeout(() => {\r\n            nodeComponentA.classList.add('visited')\r\n          }, algorithmSpeed * i);\r\n        }\r\n            if (nodeB !== undefined){\r\n            \r\n            const nodeComponentB=document.getElementById(`node-${nodeB.row}-${nodeB.col}`);\r\n        setTimeout(() => {\r\n            nodeComponentB.classList.add('node-visiting');\r\n        }, algorithmSpeed * (i - 0.8));\r\n          setTimeout(() => {\r\n            nodeComponentB.classList.add('visited')\r\n          }, algorithmSpeed * i);\r\n        }\r\n        \r\n        }\r\n      }\r\n\r\n      animateShortestPath1 = (nodesInShortestPathOrder, visitedNodesInOrder) => {\r\n        if (nodesInShortestPathOrder.length === 1)\r\n          this.setState({ visualizingAlgorithm: false });\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n          setTimeout(() => {\r\n            //shortest path node\r\n            let node = nodesInShortestPathOrder[i];\r\n            if(document.getElementById(`node-${node.row}-${node.col}`).className ===\r\n            \"node start-node node-visiting visited\"){\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node start-node node-visiting visited node-shortest-path\";\r\n            }\r\n            else if(document.getElementById(`node-${node.row}-${node.col}`).className ===\r\n            \"node finish-node node-visiting visited\"){\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node finish-node node-visiting visited node-shortest-path\";\r\n            }\r\n            else{\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-visiting visited node-shortest-path\";}\r\n          }, i * 50);\r\n        }\r\n      };\r\n\r\n      //bidirectional\r\n    findPath(algorithmCallback,getShortestPathCallback) {\r\n        let startNode = getNodeByType(this.state.grid,'start');\r\n        let finishNode =getNodeByType(this.state.grid,'finish');\r\n        const visitedNodesInOrder = algorithmCallback(\r\n            this.state.grid,\r\n            startNode,\r\n            finishNode,\r\n        \r\n        )\r\n       \r\n        const nodeInShortestPath=getShortestPathCallback(finishNode)\r\n        \r\n        this.animateAlgorithm(visitedNodesInOrder,nodeInShortestPath);\r\n    }\r\n     \r\n    animateAlgorithm(visitedNodesInOrder,nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, algorithmSpeed * i);\r\n                return;\r\n                }\r\n        const node = visitedNodesInOrder[i];\r\n        \r\n        const nodeComponent=document.getElementById(`node-${node.row}-${node.col}`);\r\n        setTimeout(() => {\r\n            nodeComponent.classList.add('node-visiting');\r\n        }, algorithmSpeed * (i - 0.8));\r\n          setTimeout(() => {\r\n            nodeComponent.classList.add('visited')\r\n          }, algorithmSpeed * i);\r\n         \r\n        }\r\n      }\r\n      animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n          setTimeout(() => {\r\n            const node = nodesInShortestPathOrder[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).classList.add('node-shortest-path')\r\n          }, 50 * i);\r\n        }\r\n      \r\n      }\r\n      visualizeMaze(algorithm) {\r\n        let newGrid\r\n        switch (algorithm) {\r\n            case 0:\r\n                break;\r\n            case 1:\r\n              this.findMaze(recursiveDivisionMaze,'wall')\r\n            break;\r\n            case 2:\r\n               this.findMaze(recursiveBacktracker,'normal-node')\r\n                break;\r\n            case 3:\r\n                this.findMaze(prim,'normal-node')\r\n            break;\r\n            case 4:\r\n                this.findMaze(spiral,'wall')\r\n                    break;\r\n            case 5:\r\n                 newGrid=randomMaze(this.state.grid,'wall')\r\n                 this.setState({grid:newGrid})\r\n                break;\r\n            case 6:\r\n                 newGrid=randomMaze(this.state.grid,'weight')\r\n                this.setState({grid:newGrid})\r\n                break;\r\n           \r\n          default:\r\n              break\r\n        }\r\n        \r\n      }\r\n      findMaze(mazeCallback,type){\r\n        this.clearWallsAndWeights(this.state.grid)\r\n        const startNode=getNodeByType(this.state.grid,'start')\r\n        const  finishNode=getNodeByType(this.state.grid,'finish')\r\n        const nodesToAnimate= mazeCallback(this.state.grid, startNode,finishNode)\r\n        this.animateMaze(nodesToAnimate,type)\r\n      }\r\n      animateMaze(nodesToAnimate,type) {\r\n        \r\n        for (let i = 1; i < nodesToAnimate.length; i++) {\r\n            \r\n          setTimeout(() => {\r\n            const node = nodesToAnimate[i];\r\n            if(node.type==='start'||node.type==='finish')return\r\n            const newGrid=getNewGridWithNewNodeType(this.state.grid,node.row,node.col,type)\r\n            this.setState({grid:newGrid})\r\n          },1);\r\n        }\r\n      }\r\n    clearWallsAndWeights(grid){\r\n        this.clearNodes(grid,'wall')\r\n        this.clearNodes(grid,'weight')\r\n    }\r\n    clearNodes(grid,type){\r\n        const newGrid=grid.slice()\r\n        for (const row of newGrid) {\r\n            for (const node of row) {\r\n               console.log(node)\r\n               if(node.type===type){\r\n                node.type=\"normal-node\"\r\n               \r\n               } \r\n            }\r\n          }\r\n        this.setState({grid:newGrid})\r\n    }\r\n  \r\n\r\n    clearBoard(){\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if(row === startNodeRow && col === startNodeCol){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node start-node\";\r\n                }\r\n                else if(row === finishNodeRow && col === finishNodeCol){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node finish-node\";\r\n                }\r\n                else {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n                }\r\n              }\r\n            const newGrid = initializeGrid();\r\n            this.setState({\r\n                grid: newGrid,\r\n                visualizingAlgorithm: false,\r\n                generatingMaze: false,\r\n            });\r\n        }\r\n        \r\n    clearPath(){\r\n            let newGrid=this.state.grid.slice();\r\n            for (let row = 0; row < this.state.grid.length; row++) {\r\n                for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if(document.getElementById(`node-${row}-${col}`).className === \"node start-node node-visiting visited node-shortest-path\") {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node start-node\";\r\n                }\r\n                else if((document.getElementById(`node-${row}-${col}`).className === \"node finish-node node-visiting visited node-shortest-path\") || (document.getElementById(`node-${row}-${col}`).className === \"node finish-node node-shortest-path\")){\r\n                    \r\n                    document.getElementById(`node-${row}-${col}`).className = \"node finish-node\";\r\n                } \r\n                else if((document.getElementById(`node-${row}-${col}`).className === \"node weight-node node-visiting visited\") || (document.getElementById(`node-${row}-${col}`).className === \"node weight-node node-visiting visited node-shortest-path\")){\r\n                    \r\n                  document.getElementById(`node-${row}-${col}`).className = \"node weight-node\";\r\n                } \r\n                else if((document.getElementById(`node-${row}-${col}`).className === \"node node-visiting visited node-shortest-path\") || (document.getElementById(`node-${row}-${col}`).className === \"node node-visiting visited\")){\r\n                    \r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                \r\n                 }\r\n                const node = newGrid[row][col];\r\n                const newNode = {\r\n                  ...node,\r\n                  distance:Infinity,\r\n                  isVisited:false,//djkstra\r\n                  previousNode:null,//djkstra, BFS\r\n                  gScore:Infinity,//astar\r\n                  fScore:Infinity,//astar\r\n                  hScore:null,//astar\r\n                  closed:false\r\n                };\r\n\r\n                newGrid[row][col] = newNode;\r\n                this.setState({\r\n                  grid: newGrid,\r\n                  \r\n              });\r\n            }\r\n            \r\n        }\r\n    }\r\n    \r\n\r\n    render(){        \r\n        const {grid} = this.state;\r\n        \r\n        return(\r\n          <div>\r\n            <div className=\"header\">\r\n                <div className=\"logo\"><span>Pathfiniding Visualizer</span></div>\r\n                <div className=\"dropdown\">\r\n                    <button className=\"dropbtn\"><span>Algorithms</span>\r\n                        <i className=\"fa fa-caret-down\"></i>\r\n                    </button>\r\n                    <div className=\"dropdown-content\">\r\n                        <button onClick={() => this.visualizeAlgorithm(1)}>Dijkstra</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(2)}>A*</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(3)}>Breadth First Search</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(4)}>Depth First Search</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(5)}>Greedy Best First Search</button>\r\n                        <button onClick={() => this.visualizeAlgorithm(6)}>Bidirectional Greedy Search</button>\r\n                    </div>\r\n                    \r\n                </div>\r\n                <div className=\"dropdown\">\r\n                    <button className=\"dropbtn\"><span>Mazes</span>\r\n                        <i className=\"fa fa-caret-down\"></i>\r\n                    </button>\r\n                    <div className=\"dropdown-content\">\r\n                        <button onClick={() => this.visualizeMaze(1)}>Recursive Division maze</button>\r\n                        <button onClick={() => this.visualizeMaze(2)}>Recursive Backtracker</button>\r\n                        <button onClick={() => this.visualizeMaze(3)}>Randomized Prim's algorithm</button>\r\n                        <button onClick={() => this.visualizeMaze(4)}>Spriral Maze</button>\r\n                        <button onClick={() => this.visualizeMaze(5)}>Random Wall Maze</button>\r\n                        <button onClick={() => this.visualizeMaze(6)}>Random Weight Maze</button>\r\n                    </div>\r\n                </div>\r\n                <div className=\"dropdown\">\r\n                <button className=\"dropbtn\"><span>Speed</span>\r\n                        <i className=\"fa fa-caret-down\"></i>\r\n                    </button>\r\n                    <div className=\"dropdown-content\">\r\n                        <button onClick={()=>changeAlgoritmSpeed(125)}>Slow</button>\r\n                        <button onClick={()=>changeAlgoritmSpeed(50)}>Medium</button>\r\n                        <button onClick={()=>changeAlgoritmSpeed(10)}>Fast</button>\r\n                    </div>\r\n                </div>\r\n                <button className=\"clear-walls\" onClick={()=>this.clearWallsAndWeights(this.state.grid)}>Clear Walls & Weights </button>\r\n                <button className=\"clear-walls\" onClick={()=>this.clearBoard()}>Clear Board </button>\r\n                <button className=\"clear-walls\" onClick={()=>this.clearPath()}>Clear Path </button>\r\n\r\n            </div>\r\n\r\n\r\n            <div id='mainGrid'>\r\n                <div id='mainText'>\r\n                    <ul>\r\n                    <li>\r\n                        <div class=\"start\"></div>Start Node</li>\r\n                    <li>\r\n                        <div class=\"target\"></div>Target Node</li>\r\n                    <li id=\"weightLegend\">\r\n                        <div class=\"borderlessWeight\"></div>Weight Node</li>\r\n                    <li>\r\n                        <div class=\"unvisited\"></div>Unvisited Node</li>\r\n                    <li>\r\n                        <div class=\"visited\"></div>Visited Nodes</li>\r\n                    <li>\r\n                        <div class=\"shortest-path\"></div>Shortest-path Node</li>\r\n                    <li>\r\n                        <div class=\"wall\"></div>Wall Node</li>\r\n                    </ul>\r\n                </div>\r\n                <div id=\"algorithmDescriptor\">Pick up an algorithm and visualize it!</div>\r\n            </div>\r\n\r\n\r\n            <table className=\"grid\">\r\n                {grid.map((row, rowIdx) => {\r\n                    return (\r\n                    <tr key={rowIdx}>\r\n                        {row.map((node, nodeIdx) => {\r\n                            const{row,col,type,isPath,isVisited,distance,gScore,fScore,hScore,closed}=node\r\n                        \r\n                        return (\r\n                            <Node \r\n                            key={nodeIdx}\r\n                            row={row}\r\n                            col={col}\r\n                            type={type}\r\n                            isPath={isPath}\r\n                            isVisited={isVisited}\r\n                            distance={distance}\r\n                            gScore={gScore}\r\n                            fScore={fScore}\r\n                            hScore={hScore}\r\n                            closed={closed}\r\n                            onMouseDown={(row, col,type) => this.handleMouseDown(row, col,type)}\r\n                            onMouseEnter={(row, col,type) => this.handleMouseEnter(row, col,type)} \r\n                            onMouseUp={() => this.handleMouseUp()} \r\n                            onMouseLeave={()=>this.handleMouseLeave(row,col,type)}\r\n                         \r\n                            ></Node>\r\n                        );\r\n                        })}\r\n                    </tr>\r\n                    );\r\n                })}\r\n                </table>\r\n            </div>\r\n        )\r\n    }\r\n   \r\n}\r\n\r\nconst initializeGrid=()=>{\r\n    const grid=[]\r\n    for (let row = 0; row < 21; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < 60; col++) {\r\n          currentRow.push(getNode(row,col));\r\n        }\r\n        grid.push(currentRow);\r\n      }\r\n      return grid\r\n}\r\nconst getNode=(row,col)=>{\r\n\r\n    const type=row===startNodeRow&&col===startNodeCol?'start':\r\n    row===finishNodeRow&&col===finishNodeCol?'finish':'normal-node'\r\n\r\n    return{\r\n        row,\r\n        col,\r\n        type,\r\n        weightValue:1,\r\n        isVisited: false,\r\n        isWall:false,\r\n        isPath:false,\r\n        distance:Infinity,//djkstra\r\n        previousNode:null,//djkstra,BFS\r\n        gScore:Infinity,//astar\r\n        fScore:Infinity,//astar\r\n        hScore:null,//astar\r\n        closed:false\r\n    }\r\n}\r\n\r\nconst getNewGridWithNewNodeType = (grid, row, col,newType) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n \r\n  const newNode = {\r\n    ...node, \r\n    type:newType,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n//This function iterates trought the array and reuturns a node with a given type\r\nconst getNodeByType =(grid,givenType)=>{\r\n  \r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n           if(node.type===givenType){\r\n               return node;\r\n           }\r\n        }\r\n      }\r\n}\r\n\r\n  \r\n  \r\nfunction changeAlgoritmSpeed(speed){\r\n    algorithmSpeed=speed\r\n}\r\n\r\n\r\nconst getVisitedNodesInOrder = (\r\n    visitedNodesInOrderStart,\r\n    visitedNodesInOrderFinish\r\n  ) => {\r\n    let visitedNodesInOrder = [];\r\n    let n = Math.max(\r\n      visitedNodesInOrderStart.length,\r\n      visitedNodesInOrderFinish.length\r\n    );\r\n    for (let i = 0; i < n; i++) {\r\n      if (visitedNodesInOrderStart[i] !== undefined) {\r\n        visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\r\n      }\r\n      if (visitedNodesInOrderFinish[i] !== undefined) {\r\n        visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\r\n      }\r\n    }\r\n    return visitedNodesInOrder;\r\n  };\r\n  ","\nimport PathfindingVisulizer from './PathfindingVisualizer/PathfindingVisualizer'\n\nfunction App() {\n  return (\n   <PathfindingVisulizer></PathfindingVisulizer>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}